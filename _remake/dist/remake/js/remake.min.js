var Remake = (() => {
  var __defProp = Object.defineProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
  var __commonJS = (callback, module) => () => {
    if (!module) {
      module = {exports: {}};
      callback(module.exports, module);
    }
    return module.exports;
  };
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defProp(target, name, {get: all[name], enumerable: true});
  };

  // node_modules/lodash/_freeGlobal.js
  var require_freeGlobal = __commonJS((exports, module) => {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module.exports = freeGlobal;
  });

  // node_modules/lodash/_root.js
  var require_root = __commonJS((exports, module) => {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module.exports = root;
  });

  // node_modules/lodash/_Symbol.js
  var require_Symbol = __commonJS((exports, module) => {
    var root = require_root();
    var Symbol = root.Symbol;
    module.exports = Symbol;
  });

  // node_modules/lodash/_arrayMap.js
  var require_arrayMap = __commonJS((exports, module) => {
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    module.exports = arrayMap;
  });

  // node_modules/lodash/isArray.js
  var require_isArray = __commonJS((exports, module) => {
    var isArray = Array.isArray;
    module.exports = isArray;
  });

  // node_modules/lodash/_getRawTag.js
  var require_getRawTag = __commonJS((exports, module) => {
    var Symbol = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol ? Symbol.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module.exports = getRawTag;
  });

  // node_modules/lodash/_objectToString.js
  var require_objectToString = __commonJS((exports, module) => {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module.exports = objectToString;
  });

  // node_modules/lodash/_baseGetTag.js
  var require_baseGetTag = __commonJS((exports, module) => {
    var Symbol = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol ? Symbol.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module.exports = baseGetTag;
  });

  // node_modules/lodash/isObjectLike.js
  var require_isObjectLike = __commonJS((exports, module) => {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module.exports = isObjectLike;
  });

  // node_modules/lodash/isSymbol.js
  var require_isSymbol = __commonJS((exports, module) => {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module.exports = isSymbol;
  });

  // node_modules/lodash/_baseToString.js
  var require_baseToString = __commonJS((exports, module) => {
    var Symbol = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol ? Symbol.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module.exports = baseToString;
  });

  // node_modules/lodash/toString.js
  var require_toString = __commonJS((exports, module) => {
    var baseToString = require_baseToString();
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    module.exports = toString;
  });

  // node_modules/lodash/_baseSlice.js
  var require_baseSlice = __commonJS((exports, module) => {
    function baseSlice(array, start, end) {
      var index = -1, length = array.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }
    module.exports = baseSlice;
  });

  // node_modules/lodash/_castSlice.js
  var require_castSlice = __commonJS((exports, module) => {
    var baseSlice = require_baseSlice();
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === void 0 ? length : end;
      return !start && end >= length ? array : baseSlice(array, start, end);
    }
    module.exports = castSlice;
  });

  // node_modules/lodash/_hasUnicode.js
  var require_hasUnicode = __commonJS((exports, module) => {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsZWJ = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    function hasUnicode(string2) {
      return reHasUnicode.test(string2);
    }
    module.exports = hasUnicode;
  });

  // node_modules/lodash/_asciiToArray.js
  var require_asciiToArray = __commonJS((exports, module) => {
    function asciiToArray(string2) {
      return string2.split("");
    }
    module.exports = asciiToArray;
  });

  // node_modules/lodash/_unicodeToArray.js
  var require_unicodeToArray = __commonJS((exports, module) => {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    function unicodeToArray(string2) {
      return string2.match(reUnicode) || [];
    }
    module.exports = unicodeToArray;
  });

  // node_modules/lodash/_stringToArray.js
  var require_stringToArray = __commonJS((exports, module) => {
    var asciiToArray = require_asciiToArray();
    var hasUnicode = require_hasUnicode();
    var unicodeToArray = require_unicodeToArray();
    function stringToArray(string2) {
      return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
    }
    module.exports = stringToArray;
  });

  // node_modules/lodash/_createCaseFirst.js
  var require_createCaseFirst = __commonJS((exports, module) => {
    var castSlice = require_castSlice();
    var hasUnicode = require_hasUnicode();
    var stringToArray = require_stringToArray();
    var toString = require_toString();
    function createCaseFirst(methodName) {
      return function(string2) {
        string2 = toString(string2);
        var strSymbols = hasUnicode(string2) ? stringToArray(string2) : void 0;
        var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    module.exports = createCaseFirst;
  });

  // node_modules/lodash/upperFirst.js
  var require_upperFirst = __commonJS((exports, module) => {
    var createCaseFirst = require_createCaseFirst();
    var upperFirst = createCaseFirst("toUpperCase");
    module.exports = upperFirst;
  });

  // node_modules/lodash/capitalize.js
  var require_capitalize = __commonJS((exports, module) => {
    var toString = require_toString();
    var upperFirst = require_upperFirst();
    function capitalize(string2) {
      return upperFirst(toString(string2).toLowerCase());
    }
    module.exports = capitalize;
  });

  // node_modules/lodash/_arrayReduce.js
  var require_arrayReduce = __commonJS((exports, module) => {
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    module.exports = arrayReduce;
  });

  // node_modules/lodash/_basePropertyOf.js
  var require_basePropertyOf = __commonJS((exports, module) => {
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? void 0 : object[key];
      };
    }
    module.exports = basePropertyOf;
  });

  // node_modules/lodash/_deburrLetter.js
  var require_deburrLetter = __commonJS((exports, module) => {
    var basePropertyOf = require_basePropertyOf();
    var deburredLetters = {
      \u00C0: "A",
      \u00C1: "A",
      \u00C2: "A",
      \u00C3: "A",
      \u00C4: "A",
      \u00C5: "A",
      \u00E0: "a",
      \u00E1: "a",
      \u00E2: "a",
      \u00E3: "a",
      \u00E4: "a",
      \u00E5: "a",
      \u00C7: "C",
      \u00E7: "c",
      \u00D0: "D",
      \u00F0: "d",
      \u00C8: "E",
      \u00C9: "E",
      \u00CA: "E",
      \u00CB: "E",
      \u00E8: "e",
      \u00E9: "e",
      \u00EA: "e",
      \u00EB: "e",
      \u00CC: "I",
      \u00CD: "I",
      \u00CE: "I",
      \u00CF: "I",
      \u00EC: "i",
      \u00ED: "i",
      \u00EE: "i",
      \u00EF: "i",
      \u00D1: "N",
      \u00F1: "n",
      \u00D2: "O",
      \u00D3: "O",
      \u00D4: "O",
      \u00D5: "O",
      \u00D6: "O",
      \u00D8: "O",
      \u00F2: "o",
      \u00F3: "o",
      \u00F4: "o",
      \u00F5: "o",
      \u00F6: "o",
      \u00F8: "o",
      \u00D9: "U",
      \u00DA: "U",
      \u00DB: "U",
      \u00DC: "U",
      \u00F9: "u",
      \u00FA: "u",
      \u00FB: "u",
      \u00FC: "u",
      \u00DD: "Y",
      \u00FD: "y",
      \u00FF: "y",
      \u00C6: "Ae",
      \u00E6: "ae",
      \u00DE: "Th",
      \u00FE: "th",
      \u00DF: "ss",
      \u0100: "A",
      \u0102: "A",
      \u0104: "A",
      \u0101: "a",
      \u0103: "a",
      \u0105: "a",
      \u0106: "C",
      \u0108: "C",
      \u010A: "C",
      \u010C: "C",
      \u0107: "c",
      \u0109: "c",
      \u010B: "c",
      \u010D: "c",
      \u010E: "D",
      \u0110: "D",
      \u010F: "d",
      \u0111: "d",
      \u0112: "E",
      \u0114: "E",
      \u0116: "E",
      \u0118: "E",
      \u011A: "E",
      \u0113: "e",
      \u0115: "e",
      \u0117: "e",
      \u0119: "e",
      \u011B: "e",
      \u011C: "G",
      \u011E: "G",
      \u0120: "G",
      \u0122: "G",
      \u011D: "g",
      \u011F: "g",
      \u0121: "g",
      \u0123: "g",
      \u0124: "H",
      \u0126: "H",
      \u0125: "h",
      \u0127: "h",
      \u0128: "I",
      \u012A: "I",
      \u012C: "I",
      \u012E: "I",
      \u0130: "I",
      \u0129: "i",
      \u012B: "i",
      \u012D: "i",
      \u012F: "i",
      \u0131: "i",
      \u0134: "J",
      \u0135: "j",
      \u0136: "K",
      \u0137: "k",
      \u0138: "k",
      \u0139: "L",
      \u013B: "L",
      \u013D: "L",
      \u013F: "L",
      \u0141: "L",
      \u013A: "l",
      \u013C: "l",
      \u013E: "l",
      \u0140: "l",
      \u0142: "l",
      \u0143: "N",
      \u0145: "N",
      \u0147: "N",
      \u014A: "N",
      \u0144: "n",
      \u0146: "n",
      \u0148: "n",
      \u014B: "n",
      \u014C: "O",
      \u014E: "O",
      \u0150: "O",
      \u014D: "o",
      \u014F: "o",
      \u0151: "o",
      \u0154: "R",
      \u0156: "R",
      \u0158: "R",
      \u0155: "r",
      \u0157: "r",
      \u0159: "r",
      \u015A: "S",
      \u015C: "S",
      \u015E: "S",
      \u0160: "S",
      \u015B: "s",
      \u015D: "s",
      \u015F: "s",
      \u0161: "s",
      \u0162: "T",
      \u0164: "T",
      \u0166: "T",
      \u0163: "t",
      \u0165: "t",
      \u0167: "t",
      \u0168: "U",
      \u016A: "U",
      \u016C: "U",
      \u016E: "U",
      \u0170: "U",
      \u0172: "U",
      \u0169: "u",
      \u016B: "u",
      \u016D: "u",
      \u016F: "u",
      \u0171: "u",
      \u0173: "u",
      \u0174: "W",
      \u0175: "w",
      \u0176: "Y",
      \u0177: "y",
      \u0178: "Y",
      \u0179: "Z",
      \u017B: "Z",
      \u017D: "Z",
      \u017A: "z",
      \u017C: "z",
      \u017E: "z",
      \u0132: "IJ",
      \u0133: "ij",
      \u0152: "Oe",
      \u0153: "oe",
      \u0149: "'n",
      \u017F: "s"
    };
    var deburrLetter = basePropertyOf(deburredLetters);
    module.exports = deburrLetter;
  });

  // node_modules/lodash/deburr.js
  var require_deburr = __commonJS((exports, module) => {
    var deburrLetter = require_deburrLetter();
    var toString = require_toString();
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsCombo = "[" + rsComboRange + "]";
    var reComboMark = RegExp(rsCombo, "g");
    function deburr(string2) {
      string2 = toString(string2);
      return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    module.exports = deburr;
  });

  // node_modules/lodash/_asciiWords.js
  var require_asciiWords = __commonJS((exports, module) => {
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    function asciiWords(string2) {
      return string2.match(reAsciiWord) || [];
    }
    module.exports = asciiWords;
  });

  // node_modules/lodash/_hasUnicodeWord.js
  var require_hasUnicodeWord = __commonJS((exports, module) => {
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    function hasUnicodeWord(string2) {
      return reHasUnicodeWord.test(string2);
    }
    module.exports = hasUnicodeWord;
  });

  // node_modules/lodash/_unicodeWords.js
  var require_unicodeWords = __commonJS((exports, module) => {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsDingbatRange = "\\u2700-\\u27bf";
    var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
    var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
    var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
    var rsPunctuationRange = "\\u2000-\\u206f";
    var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
    var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]";
    var rsBreak = "[" + rsBreakRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsDigits = "\\d+";
    var rsDingbat = "[" + rsDingbatRange + "]";
    var rsLower = "[" + rsLowerRange + "]";
    var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsUpper = "[" + rsUpperRange + "]";
    var rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
    var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
    var rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
    var rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
    var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    function unicodeWords(string2) {
      return string2.match(reUnicodeWord) || [];
    }
    module.exports = unicodeWords;
  });

  // node_modules/lodash/words.js
  var require_words = __commonJS((exports, module) => {
    var asciiWords = require_asciiWords();
    var hasUnicodeWord = require_hasUnicodeWord();
    var toString = require_toString();
    var unicodeWords = require_unicodeWords();
    function words(string2, pattern, guard) {
      string2 = toString(string2);
      pattern = guard ? void 0 : pattern;
      if (pattern === void 0) {
        return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
      }
      return string2.match(pattern) || [];
    }
    module.exports = words;
  });

  // node_modules/lodash/_createCompounder.js
  var require_createCompounder = __commonJS((exports, module) => {
    var arrayReduce = require_arrayReduce();
    var deburr = require_deburr();
    var words = require_words();
    var rsApos = "['\u2019]";
    var reApos = RegExp(rsApos, "g");
    function createCompounder(callback) {
      return function(string2) {
        return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
      };
    }
    module.exports = createCompounder;
  });

  // node_modules/lodash/camelCase.js
  var require_camelCase = __commonJS((exports, module) => {
    var capitalize = require_capitalize();
    var createCompounder = require_createCompounder();
    var camelCase5 = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });
    module.exports = camelCase5;
  });

  // node_modules/lodash/isObject.js
  var require_isObject = __commonJS((exports, module) => {
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module.exports = isObject;
  });

  // node_modules/lodash/isFunction.js
  var require_isFunction = __commonJS((exports, module) => {
    var baseGetTag = require_baseGetTag();
    var isObject = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module.exports = isFunction;
  });

  // node_modules/lodash/_coreJsData.js
  var require_coreJsData = __commonJS((exports, module) => {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module.exports = coreJsData;
  });

  // node_modules/lodash/_isMasked.js
  var require_isMasked = __commonJS((exports, module) => {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module.exports = isMasked;
  });

  // node_modules/lodash/_toSource.js
  var require_toSource = __commonJS((exports, module) => {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    module.exports = toSource;
  });

  // node_modules/lodash/_baseIsNative.js
  var require_baseIsNative = __commonJS((exports, module) => {
    var isFunction = require_isFunction();
    var isMasked = require_isMasked();
    var isObject = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module.exports = baseIsNative;
  });

  // node_modules/lodash/_getValue.js
  var require_getValue = __commonJS((exports, module) => {
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    module.exports = getValue;
  });

  // node_modules/lodash/_getNative.js
  var require_getNative = __commonJS((exports, module) => {
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    module.exports = getNative;
  });

  // node_modules/lodash/_nativeCreate.js
  var require_nativeCreate = __commonJS((exports, module) => {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module.exports = nativeCreate;
  });

  // node_modules/lodash/_hashClear.js
  var require_hashClear = __commonJS((exports, module) => {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module.exports = hashClear;
  });

  // node_modules/lodash/_hashDelete.js
  var require_hashDelete = __commonJS((exports, module) => {
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = hashDelete;
  });

  // node_modules/lodash/_hashGet.js
  var require_hashGet = __commonJS((exports, module) => {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data2 = this.__data__;
      if (nativeCreate) {
        var result = data2[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data2, key) ? data2[key] : void 0;
    }
    module.exports = hashGet;
  });

  // node_modules/lodash/_hashHas.js
  var require_hashHas = __commonJS((exports, module) => {
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data2 = this.__data__;
      return nativeCreate ? data2[key] !== void 0 : hasOwnProperty.call(data2, key);
    }
    module.exports = hashHas;
  });

  // node_modules/lodash/_hashSet.js
  var require_hashSet = __commonJS((exports, module) => {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data2 = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data2[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module.exports = hashSet;
  });

  // node_modules/lodash/_Hash.js
  var require_Hash = __commonJS((exports, module) => {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module.exports = Hash;
  });

  // node_modules/lodash/_listCacheClear.js
  var require_listCacheClear = __commonJS((exports, module) => {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module.exports = listCacheClear;
  });

  // node_modules/lodash/eq.js
  var require_eq = __commonJS((exports, module) => {
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module.exports = eq;
  });

  // node_modules/lodash/_assocIndexOf.js
  var require_assocIndexOf = __commonJS((exports, module) => {
    var eq = require_eq();
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    module.exports = assocIndexOf;
  });

  // node_modules/lodash/_listCacheDelete.js
  var require_listCacheDelete = __commonJS((exports, module) => {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data2 = this.__data__, index = assocIndexOf(data2, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data2.length - 1;
      if (index == lastIndex) {
        data2.pop();
      } else {
        splice.call(data2, index, 1);
      }
      --this.size;
      return true;
    }
    module.exports = listCacheDelete;
  });

  // node_modules/lodash/_listCacheGet.js
  var require_listCacheGet = __commonJS((exports, module) => {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data2 = this.__data__, index = assocIndexOf(data2, key);
      return index < 0 ? void 0 : data2[index][1];
    }
    module.exports = listCacheGet;
  });

  // node_modules/lodash/_listCacheHas.js
  var require_listCacheHas = __commonJS((exports, module) => {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module.exports = listCacheHas;
  });

  // node_modules/lodash/_listCacheSet.js
  var require_listCacheSet = __commonJS((exports, module) => {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data2 = this.__data__, index = assocIndexOf(data2, key);
      if (index < 0) {
        ++this.size;
        data2.push([key, value]);
      } else {
        data2[index][1] = value;
      }
      return this;
    }
    module.exports = listCacheSet;
  });

  // node_modules/lodash/_ListCache.js
  var require_ListCache = __commonJS((exports, module) => {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module.exports = ListCache;
  });

  // node_modules/lodash/_Map.js
  var require_Map = __commonJS((exports, module) => {
    var getNative = require_getNative();
    var root = require_root();
    var Map3 = getNative(root, "Map");
    module.exports = Map3;
  });

  // node_modules/lodash/_mapCacheClear.js
  var require_mapCacheClear = __commonJS((exports, module) => {
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map3 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        hash: new Hash(),
        map: new (Map3 || ListCache)(),
        string: new Hash()
      };
    }
    module.exports = mapCacheClear;
  });

  // node_modules/lodash/_isKeyable.js
  var require_isKeyable = __commonJS((exports, module) => {
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module.exports = isKeyable;
  });

  // node_modules/lodash/_getMapData.js
  var require_getMapData = __commonJS((exports, module) => {
    var isKeyable = require_isKeyable();
    function getMapData(map2, key) {
      var data2 = map2.__data__;
      return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
    }
    module.exports = getMapData;
  });

  // node_modules/lodash/_mapCacheDelete.js
  var require_mapCacheDelete = __commonJS((exports, module) => {
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = mapCacheDelete;
  });

  // node_modules/lodash/_mapCacheGet.js
  var require_mapCacheGet = __commonJS((exports, module) => {
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module.exports = mapCacheGet;
  });

  // node_modules/lodash/_mapCacheHas.js
  var require_mapCacheHas = __commonJS((exports, module) => {
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module.exports = mapCacheHas;
  });

  // node_modules/lodash/_mapCacheSet.js
  var require_mapCacheSet = __commonJS((exports, module) => {
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data2 = getMapData(this, key), size = data2.size;
      data2.set(key, value);
      this.size += data2.size == size ? 0 : 1;
      return this;
    }
    module.exports = mapCacheSet;
  });

  // node_modules/lodash/_MapCache.js
  var require_MapCache = __commonJS((exports, module) => {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module.exports = MapCache;
  });

  // node_modules/lodash/_setCacheAdd.js
  var require_setCacheAdd = __commonJS((exports, module) => {
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    module.exports = setCacheAdd;
  });

  // node_modules/lodash/_setCacheHas.js
  var require_setCacheHas = __commonJS((exports, module) => {
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    module.exports = setCacheHas;
  });

  // node_modules/lodash/_SetCache.js
  var require_SetCache = __commonJS((exports, module) => {
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module.exports = SetCache;
  });

  // node_modules/lodash/_baseFindIndex.js
  var require_baseFindIndex = __commonJS((exports, module) => {
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    module.exports = baseFindIndex;
  });

  // node_modules/lodash/_baseIsNaN.js
  var require_baseIsNaN = __commonJS((exports, module) => {
    function baseIsNaN(value) {
      return value !== value;
    }
    module.exports = baseIsNaN;
  });

  // node_modules/lodash/_strictIndexOf.js
  var require_strictIndexOf = __commonJS((exports, module) => {
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    module.exports = strictIndexOf;
  });

  // node_modules/lodash/_baseIndexOf.js
  var require_baseIndexOf = __commonJS((exports, module) => {
    var baseFindIndex = require_baseFindIndex();
    var baseIsNaN = require_baseIsNaN();
    var strictIndexOf = require_strictIndexOf();
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    module.exports = baseIndexOf;
  });

  // node_modules/lodash/_arrayIncludes.js
  var require_arrayIncludes = __commonJS((exports, module) => {
    var baseIndexOf = require_baseIndexOf();
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    module.exports = arrayIncludes;
  });

  // node_modules/lodash/_arrayIncludesWith.js
  var require_arrayIncludesWith = __commonJS((exports, module) => {
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    module.exports = arrayIncludesWith;
  });

  // node_modules/lodash/_baseUnary.js
  var require_baseUnary = __commonJS((exports, module) => {
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module.exports = baseUnary;
  });

  // node_modules/lodash/_cacheHas.js
  var require_cacheHas = __commonJS((exports, module) => {
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    module.exports = cacheHas;
  });

  // node_modules/lodash/_baseDifference.js
  var require_baseDifference = __commonJS((exports, module) => {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var arrayMap = require_arrayMap();
    var baseUnary = require_baseUnary();
    var cacheHas = require_cacheHas();
    var LARGE_ARRAY_SIZE = 200;
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      } else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee == null ? value : iteratee(value);
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }
            result.push(value);
          } else if (!includes(values, computed, comparator)) {
            result.push(value);
          }
        }
      return result;
    }
    module.exports = baseDifference;
  });

  // node_modules/lodash/_arrayPush.js
  var require_arrayPush = __commonJS((exports, module) => {
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    module.exports = arrayPush;
  });

  // node_modules/lodash/_baseIsArguments.js
  var require_baseIsArguments = __commonJS((exports, module) => {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module.exports = baseIsArguments;
  });

  // node_modules/lodash/isArguments.js
  var require_isArguments = __commonJS((exports, module) => {
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module.exports = isArguments;
  });

  // node_modules/lodash/_isFlattenable.js
  var require_isFlattenable = __commonJS((exports, module) => {
    var Symbol = require_Symbol();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : void 0;
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    module.exports = isFlattenable;
  });

  // node_modules/lodash/_baseFlatten.js
  var require_baseFlatten = __commonJS((exports, module) => {
    var arrayPush = require_arrayPush();
    var isFlattenable = require_isFlattenable();
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    module.exports = baseFlatten;
  });

  // node_modules/lodash/identity.js
  var require_identity = __commonJS((exports, module) => {
    function identity(value) {
      return value;
    }
    module.exports = identity;
  });

  // node_modules/lodash/_apply.js
  var require_apply = __commonJS((exports, module) => {
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    module.exports = apply;
  });

  // node_modules/lodash/_overRest.js
  var require_overRest = __commonJS((exports, module) => {
    var apply = require_apply();
    var nativeMax = Math.max;
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    module.exports = overRest;
  });

  // node_modules/lodash/constant.js
  var require_constant = __commonJS((exports, module) => {
    function constant(value) {
      return function() {
        return value;
      };
    }
    module.exports = constant;
  });

  // node_modules/lodash/_defineProperty.js
  var require_defineProperty = __commonJS((exports, module) => {
    var getNative = require_getNative();
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    module.exports = defineProperty;
  });

  // node_modules/lodash/_baseSetToString.js
  var require_baseSetToString = __commonJS((exports, module) => {
    var constant = require_constant();
    var defineProperty = require_defineProperty();
    var identity = require_identity();
    var baseSetToString = !defineProperty ? identity : function(func, string2) {
      return defineProperty(func, "toString", {
        configurable: true,
        enumerable: false,
        value: constant(string2),
        writable: true
      });
    };
    module.exports = baseSetToString;
  });

  // node_modules/lodash/_shortOut.js
  var require_shortOut = __commonJS((exports, module) => {
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    module.exports = shortOut;
  });

  // node_modules/lodash/_setToString.js
  var require_setToString = __commonJS((exports, module) => {
    var baseSetToString = require_baseSetToString();
    var shortOut = require_shortOut();
    var setToString = shortOut(baseSetToString);
    module.exports = setToString;
  });

  // node_modules/lodash/_baseRest.js
  var require_baseRest = __commonJS((exports, module) => {
    var identity = require_identity();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    module.exports = baseRest;
  });

  // node_modules/lodash/isLength.js
  var require_isLength = __commonJS((exports, module) => {
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module.exports = isLength;
  });

  // node_modules/lodash/isArrayLike.js
  var require_isArrayLike = __commonJS((exports, module) => {
    var isFunction = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    module.exports = isArrayLike;
  });

  // node_modules/lodash/isArrayLikeObject.js
  var require_isArrayLikeObject = __commonJS((exports, module) => {
    var isArrayLike = require_isArrayLike();
    var isObjectLike = require_isObjectLike();
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    module.exports = isArrayLikeObject;
  });

  // node_modules/lodash/difference.js
  var require_difference = __commonJS((exports, module) => {
    var baseDifference = require_baseDifference();
    var baseFlatten = require_baseFlatten();
    var baseRest = require_baseRest();
    var isArrayLikeObject = require_isArrayLikeObject();
    var difference2 = baseRest(function(array, values) {
      return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
    });
    module.exports = difference2;
  });

  // node_modules/lodash/kebabCase.js
  var require_kebabCase = __commonJS((exports, module) => {
    var createCompounder = require_createCompounder();
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? "-" : "") + word.toLowerCase();
    });
    module.exports = kebabCase;
  });

  // node_modules/lodash/now.js
  var require_now = __commonJS((exports, module) => {
    var root = require_root();
    var now = function() {
      return root.Date.now();
    };
    module.exports = now;
  });

  // node_modules/lodash/toNumber.js
  var require_toNumber = __commonJS((exports, module) => {
    var isObject = require_isObject();
    var isSymbol = require_isSymbol();
    var NAN = 0 / 0;
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = toNumber;
  });

  // node_modules/lodash/debounce.js
  var require_debounce = __commonJS((exports, module) => {
    var isObject = require_isObject();
    var now = require_now();
    var toNumber = require_toNumber();
    var FUNC_ERROR_TEXT = "Expected a function";
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    function debounce3(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    module.exports = debounce3;
  });

  // node_modules/lodash/_stackClear.js
  var require_stackClear = __commonJS((exports, module) => {
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    module.exports = stackClear;
  });

  // node_modules/lodash/_stackDelete.js
  var require_stackDelete = __commonJS((exports, module) => {
    function stackDelete(key) {
      var data2 = this.__data__, result = data2["delete"](key);
      this.size = data2.size;
      return result;
    }
    module.exports = stackDelete;
  });

  // node_modules/lodash/_stackGet.js
  var require_stackGet = __commonJS((exports, module) => {
    function stackGet(key) {
      return this.__data__.get(key);
    }
    module.exports = stackGet;
  });

  // node_modules/lodash/_stackHas.js
  var require_stackHas = __commonJS((exports, module) => {
    function stackHas(key) {
      return this.__data__.has(key);
    }
    module.exports = stackHas;
  });

  // node_modules/lodash/_stackSet.js
  var require_stackSet = __commonJS((exports, module) => {
    var ListCache = require_ListCache();
    var Map3 = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data2 = this.__data__;
      if (data2 instanceof ListCache) {
        var pairs = data2.__data__;
        if (!Map3 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data2.size;
          return this;
        }
        data2 = this.__data__ = new MapCache(pairs);
      }
      data2.set(key, value);
      this.size = data2.size;
      return this;
    }
    module.exports = stackSet;
  });

  // node_modules/lodash/_Stack.js
  var require_Stack = __commonJS((exports, module) => {
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack(entries) {
      var data2 = this.__data__ = new ListCache(entries);
      this.size = data2.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module.exports = Stack;
  });

  // node_modules/lodash/_baseAssignValue.js
  var require_baseAssignValue = __commonJS((exports, module) => {
    var defineProperty = require_defineProperty();
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      } else {
        object[key] = value;
      }
    }
    module.exports = baseAssignValue;
  });

  // node_modules/lodash/_assignMergeValue.js
  var require_assignMergeValue = __commonJS((exports, module) => {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    module.exports = assignMergeValue;
  });

  // node_modules/lodash/_createBaseFor.js
  var require_createBaseFor = __commonJS((exports, module) => {
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    module.exports = createBaseFor;
  });

  // node_modules/lodash/_baseFor.js
  var require_baseFor = __commonJS((exports, module) => {
    var createBaseFor = require_createBaseFor();
    var baseFor = createBaseFor();
    module.exports = baseFor;
  });

  // node_modules/lodash/_cloneBuffer.js
  var require_cloneBuffer = __commonJS((exports, module) => {
    var root = require_root();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    module.exports = cloneBuffer;
  });

  // node_modules/lodash/_Uint8Array.js
  var require_Uint8Array = __commonJS((exports, module) => {
    var root = require_root();
    var Uint8Array2 = root.Uint8Array;
    module.exports = Uint8Array2;
  });

  // node_modules/lodash/_cloneArrayBuffer.js
  var require_cloneArrayBuffer = __commonJS((exports, module) => {
    var Uint8Array2 = require_Uint8Array();
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    module.exports = cloneArrayBuffer;
  });

  // node_modules/lodash/_cloneTypedArray.js
  var require_cloneTypedArray = __commonJS((exports, module) => {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    module.exports = cloneTypedArray;
  });

  // node_modules/lodash/_copyArray.js
  var require_copyArray = __commonJS((exports, module) => {
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    module.exports = copyArray;
  });

  // node_modules/lodash/_baseCreate.js
  var require_baseCreate = __commonJS((exports, module) => {
    var isObject = require_isObject();
    var objectCreate = Object.create;
    var baseCreate = function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    module.exports = baseCreate;
  });

  // node_modules/lodash/_overArg.js
  var require_overArg = __commonJS((exports, module) => {
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module.exports = overArg;
  });

  // node_modules/lodash/_getPrototype.js
  var require_getPrototype = __commonJS((exports, module) => {
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    module.exports = getPrototype;
  });

  // node_modules/lodash/_isPrototype.js
  var require_isPrototype = __commonJS((exports, module) => {
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module.exports = isPrototype;
  });

  // node_modules/lodash/_initCloneObject.js
  var require_initCloneObject = __commonJS((exports, module) => {
    var baseCreate = require_baseCreate();
    var getPrototype = require_getPrototype();
    var isPrototype = require_isPrototype();
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    module.exports = initCloneObject;
  });

  // node_modules/lodash/stubFalse.js
  var require_stubFalse = __commonJS((exports, module) => {
    function stubFalse() {
      return false;
    }
    module.exports = stubFalse;
  });

  // node_modules/lodash/isBuffer.js
  var require_isBuffer = __commonJS((exports, module) => {
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module.exports = isBuffer;
  });

  // node_modules/lodash/isPlainObject.js
  var require_isPlainObject = __commonJS((exports, module) => {
    var baseGetTag = require_baseGetTag();
    var getPrototype = require_getPrototype();
    var isObjectLike = require_isObjectLike();
    var objectTag = "[object Object]";
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module.exports = isPlainObject;
  });

  // node_modules/lodash/_baseIsTypedArray.js
  var require_baseIsTypedArray = __commonJS((exports, module) => {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module.exports = baseIsTypedArray;
  });

  // node_modules/lodash/_nodeUtil.js
  var require_nodeUtil = __commonJS((exports, module) => {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module.exports = nodeUtil;
  });

  // node_modules/lodash/isTypedArray.js
  var require_isTypedArray = __commonJS((exports, module) => {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module.exports = isTypedArray;
  });

  // node_modules/lodash/_safeGet.js
  var require_safeGet = __commonJS((exports, module) => {
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    module.exports = safeGet;
  });

  // node_modules/lodash/_assignValue.js
  var require_assignValue = __commonJS((exports, module) => {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    module.exports = assignValue;
  });

  // node_modules/lodash/_copyObject.js
  var require_copyObject = __commonJS((exports, module) => {
    var assignValue = require_assignValue();
    var baseAssignValue = require_baseAssignValue();
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    module.exports = copyObject;
  });

  // node_modules/lodash/_baseTimes.js
  var require_baseTimes = __commonJS((exports, module) => {
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    module.exports = baseTimes;
  });

  // node_modules/lodash/_isIndex.js
  var require_isIndex = __commonJS((exports, module) => {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    module.exports = isIndex;
  });

  // node_modules/lodash/_arrayLikeKeys.js
  var require_arrayLikeKeys = __commonJS((exports, module) => {
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = arrayLikeKeys;
  });

  // node_modules/lodash/_nativeKeysIn.js
  var require_nativeKeysIn = __commonJS((exports, module) => {
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = nativeKeysIn;
  });

  // node_modules/lodash/_baseKeysIn.js
  var require_baseKeysIn = __commonJS((exports, module) => {
    var isObject = require_isObject();
    var isPrototype = require_isPrototype();
    var nativeKeysIn = require_nativeKeysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = baseKeysIn;
  });

  // node_modules/lodash/keysIn.js
  var require_keysIn = __commonJS((exports, module) => {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeysIn = require_baseKeysIn();
    var isArrayLike = require_isArrayLike();
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    module.exports = keysIn;
  });

  // node_modules/lodash/toPlainObject.js
  var require_toPlainObject = __commonJS((exports, module) => {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    module.exports = toPlainObject;
  });

  // node_modules/lodash/_baseMergeDeep.js
  var require_baseMergeDeep = __commonJS((exports, module) => {
    var assignMergeValue = require_assignMergeValue();
    var cloneBuffer = require_cloneBuffer();
    var cloneTypedArray = require_cloneTypedArray();
    var copyArray = require_copyArray();
    var initCloneObject = require_initCloneObject();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isArrayLikeObject = require_isArrayLikeObject();
    var isBuffer = require_isBuffer();
    var isFunction = require_isFunction();
    var isObject = require_isObject();
    var isPlainObject = require_isPlainObject();
    var isTypedArray = require_isTypedArray();
    var safeGet = require_safeGet();
    var toPlainObject = require_toPlainObject();
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    module.exports = baseMergeDeep;
  });

  // node_modules/lodash/_baseMerge.js
  var require_baseMerge = __commonJS((exports, module) => {
    var Stack = require_Stack();
    var assignMergeValue = require_assignMergeValue();
    var baseFor = require_baseFor();
    var baseMergeDeep = require_baseMergeDeep();
    var isObject = require_isObject();
    var keysIn = require_keysIn();
    var safeGet = require_safeGet();
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    module.exports = baseMerge;
  });

  // node_modules/lodash/_isIterateeCall.js
  var require_isIterateeCall = __commonJS((exports, module) => {
    var eq = require_eq();
    var isArrayLike = require_isArrayLike();
    var isIndex = require_isIndex();
    var isObject = require_isObject();
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    module.exports = isIterateeCall;
  });

  // node_modules/lodash/_createAssigner.js
  var require_createAssigner = __commonJS((exports, module) => {
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    module.exports = createAssigner;
  });

  // node_modules/lodash/merge.js
  var require_merge = __commonJS((exports, module) => {
    var baseMerge = require_baseMerge();
    var createAssigner = require_createAssigner();
    var merge2 = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    module.exports = merge2;
  });

  // _remake/client-side/index.js
  var require_client_side = __commonJS((exports) => {
    __export(exports, {
      $: () => $,
      callSaveFunction: () => callSaveFunction,
      callWatchFunctionsOnElements: () => callWatchFunctionsOnElements,
      copyLayout: () => copyLayout,
      getClosestElemWithKey: () => getClosestElemWithKey,
      getKeyNamesFromElem: () => getKeyNamesFromElem,
      getSaveData: () => getSaveData,
      getValueForClosestKey: () => getValueForClosestKey,
      getValueForKeyName: () => getValueForKeyName,
      init: () => init,
      onAddItem: () => onAddItem,
      onFileUpload: () => onFileUpload,
      onFileUploadProgress: () => onFileUploadProgress,
      onSave: () => onSave2,
      onSync: () => onSync,
      setAllDataToEmptyStringsExceptIds: () => setAllDataToEmptyStringsExceptIds,
      setValueForClosestKey: () => setValueForClosestKey,
      setValueForKeyName: () => setValueForKeyName
    });
  });

  // node_modules/selector-set/selector-set.next.js
  function SelectorSet() {
    if (!(this instanceof SelectorSet)) {
      return new SelectorSet();
    }
    this.size = 0;
    this.uid = 0;
    this.selectors = [];
    this.selectorObjects = {};
    this.indexes = Object.create(this.indexes);
    this.activeIndexes = [];
  }
  var docElem = window.document.documentElement;
  var matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector;
  SelectorSet.prototype.matchesSelector = function(el, selector) {
    return matches.call(el, selector);
  };
  SelectorSet.prototype.querySelectorAll = function(selectors, context) {
    return context.querySelectorAll(selectors);
  };
  SelectorSet.prototype.indexes = [];
  var idRe = /^#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
  SelectorSet.prototype.indexes.push({
    name: "ID",
    selector: function matchIdSelector(sel) {
      var m;
      if (m = sel.match(idRe)) {
        return m[0].slice(1);
      }
    },
    element: function getElementId(el) {
      if (el.id) {
        return [el.id];
      }
    }
  });
  var classRe = /^\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
  SelectorSet.prototype.indexes.push({
    name: "CLASS",
    selector: function matchClassSelector(sel) {
      var m;
      if (m = sel.match(classRe)) {
        return m[0].slice(1);
      }
    },
    element: function getElementClassNames(el) {
      var className = el.className;
      if (className) {
        if (typeof className === "string") {
          return className.split(/\s/);
        } else if (typeof className === "object" && "baseVal" in className) {
          return className.baseVal.split(/\s/);
        }
      }
    }
  });
  var tagRe = /^((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
  SelectorSet.prototype.indexes.push({
    name: "TAG",
    selector: function matchTagSelector(sel) {
      var m;
      if (m = sel.match(tagRe)) {
        return m[0].toUpperCase();
      }
    },
    element: function getElementTagName(el) {
      return [el.nodeName.toUpperCase()];
    }
  });
  SelectorSet.prototype.indexes["default"] = {
    name: "UNIVERSAL",
    selector: function() {
      return true;
    },
    element: function() {
      return [true];
    }
  };
  var Map2;
  if (typeof window.Map === "function") {
    Map2 = window.Map;
  } else {
    Map2 = function() {
      function Map3() {
        this.map = {};
      }
      Map3.prototype.get = function(key) {
        return this.map[key + " "];
      };
      Map3.prototype.set = function(key, value) {
        this.map[key + " "] = value;
      };
      return Map3;
    }();
  }
  var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g;
  function parseSelectorIndexes(allIndexes, selector) {
    allIndexes = allIndexes.slice(0).concat(allIndexes["default"]);
    var allIndexesLen = allIndexes.length, i, j, m, dup, rest = selector, key, index, indexes = [];
    do {
      chunker.exec("");
      if (m = chunker.exec(rest)) {
        rest = m[3];
        if (m[2] || !rest) {
          for (i = 0; i < allIndexesLen; i++) {
            index = allIndexes[i];
            if (key = index.selector(m[1])) {
              j = indexes.length;
              dup = false;
              while (j--) {
                if (indexes[j].index === index && indexes[j].key === key) {
                  dup = true;
                  break;
                }
              }
              if (!dup) {
                indexes.push({index, key});
              }
              break;
            }
          }
        }
      }
    } while (m);
    return indexes;
  }
  function findByPrototype(ary, proto) {
    var i, len, item;
    for (i = 0, len = ary.length; i < len; i++) {
      item = ary[i];
      if (proto.isPrototypeOf(item)) {
        return item;
      }
    }
  }
  SelectorSet.prototype.logDefaultIndexUsed = function() {
  };
  SelectorSet.prototype.add = function(selector, data2) {
    var obj, i, indexProto, key, index, objs, selectorIndexes, selectorIndex, indexes = this.activeIndexes, selectors = this.selectors, selectorObjects = this.selectorObjects;
    if (typeof selector !== "string") {
      return;
    }
    obj = {
      id: this.uid++,
      selector,
      data: data2
    };
    selectorObjects[obj.id] = obj;
    selectorIndexes = parseSelectorIndexes(this.indexes, selector);
    for (i = 0; i < selectorIndexes.length; i++) {
      selectorIndex = selectorIndexes[i];
      key = selectorIndex.key;
      indexProto = selectorIndex.index;
      index = findByPrototype(indexes, indexProto);
      if (!index) {
        index = Object.create(indexProto);
        index.map = new Map2();
        indexes.push(index);
      }
      if (indexProto === this.indexes["default"]) {
        this.logDefaultIndexUsed(obj);
      }
      objs = index.map.get(key);
      if (!objs) {
        objs = [];
        index.map.set(key, objs);
      }
      objs.push(obj);
    }
    this.size++;
    selectors.push(selector);
  };
  SelectorSet.prototype.remove = function(selector, data2) {
    if (typeof selector !== "string") {
      return;
    }
    var selectorIndexes, selectorIndex, i, j, k, selIndex, objs, obj, indexes = this.activeIndexes, selectors = this.selectors = [], selectorObjects = this.selectorObjects, removedIds = {}, removeAll = arguments.length === 1;
    selectorIndexes = parseSelectorIndexes(this.indexes, selector);
    for (i = 0; i < selectorIndexes.length; i++) {
      selectorIndex = selectorIndexes[i];
      j = indexes.length;
      while (j--) {
        selIndex = indexes[j];
        if (selectorIndex.index.isPrototypeOf(selIndex)) {
          objs = selIndex.map.get(selectorIndex.key);
          if (objs) {
            k = objs.length;
            while (k--) {
              obj = objs[k];
              if (obj.selector === selector && (removeAll || obj.data === data2)) {
                objs.splice(k, 1);
                removedIds[obj.id] = true;
              }
            }
          }
          break;
        }
      }
    }
    for (i in removedIds) {
      delete selectorObjects[i];
      this.size--;
    }
    for (i in selectorObjects) {
      selectors.push(selectorObjects[i].selector);
    }
  };
  function sortById(a, b) {
    return a.id - b.id;
  }
  SelectorSet.prototype.queryAll = function(context) {
    if (!this.selectors.length) {
      return [];
    }
    var matches3 = {}, results = [];
    var els = this.querySelectorAll(this.selectors.join(", "), context);
    var i, j, len, len2, el, m, match, obj;
    for (i = 0, len = els.length; i < len; i++) {
      el = els[i];
      m = this.matches(el);
      for (j = 0, len2 = m.length; j < len2; j++) {
        obj = m[j];
        if (!matches3[obj.id]) {
          match = {
            id: obj.id,
            selector: obj.selector,
            data: obj.data,
            elements: []
          };
          matches3[obj.id] = match;
          results.push(match);
        } else {
          match = matches3[obj.id];
        }
        match.elements.push(el);
      }
    }
    return results.sort(sortById);
  };
  SelectorSet.prototype.matches = function(el) {
    if (!el) {
      return [];
    }
    var i, j, k, len, len2, len3, index, keys, objs, obj, id;
    var indexes = this.activeIndexes, matchedIds = {}, matches3 = [];
    for (i = 0, len = indexes.length; i < len; i++) {
      index = indexes[i];
      keys = index.element(el);
      if (keys) {
        for (j = 0, len2 = keys.length; j < len2; j++) {
          if (objs = index.map.get(keys[j])) {
            for (k = 0, len3 = objs.length; k < len3; k++) {
              obj = objs[k];
              id = obj.id;
              if (!matchedIds[id] && this.matchesSelector(el, obj.selector)) {
                matchedIds[id] = true;
                matches3.push(obj);
              }
            }
          }
        }
      }
    }
    return matches3.sort(sortById);
  };

  // node_modules/delegated-events/dist/index.esm.js
  var bubbleEvents = {};
  var captureEvents = {};
  var propagationStopped = new WeakMap();
  var immediatePropagationStopped = new WeakMap();
  var currentTargets = new WeakMap();
  var currentTargetDesc = Object.getOwnPropertyDescriptor(Event.prototype, "currentTarget");
  function before(subject, verb, fn) {
    var source = subject[verb];
    subject[verb] = function() {
      fn.apply(subject, arguments);
      return source.apply(subject, arguments);
    };
    return subject;
  }
  function matches2(selectors, target, reverse) {
    var queue = [];
    var node = target;
    do {
      if (node.nodeType !== 1)
        break;
      var _matches = selectors.matches(node);
      if (_matches.length) {
        var matched = {
          node,
          observers: _matches
        };
        if (reverse) {
          queue.unshift(matched);
        } else {
          queue.push(matched);
        }
      }
    } while (node = node.parentElement);
    return queue;
  }
  function trackPropagation() {
    propagationStopped.set(this, true);
  }
  function trackImmediate() {
    propagationStopped.set(this, true);
    immediatePropagationStopped.set(this, true);
  }
  function getCurrentTarget() {
    return currentTargets.get(this) || null;
  }
  function defineCurrentTarget(event, getter) {
    if (!currentTargetDesc)
      return;
    Object.defineProperty(event, "currentTarget", {
      configurable: true,
      enumerable: true,
      get: getter || currentTargetDesc.get
    });
  }
  function dispatch(event) {
    var events = event.eventPhase === 1 ? captureEvents : bubbleEvents;
    var selectors = events[event.type];
    if (!selectors)
      return;
    var queue = matches2(selectors, event.target, event.eventPhase === 1);
    if (!queue.length)
      return;
    before(event, "stopPropagation", trackPropagation);
    before(event, "stopImmediatePropagation", trackImmediate);
    defineCurrentTarget(event, getCurrentTarget);
    for (var i = 0, len1 = queue.length; i < len1; i++) {
      if (propagationStopped.get(event))
        break;
      var matched = queue[i];
      currentTargets.set(event, matched.node);
      for (var j = 0, len2 = matched.observers.length; j < len2; j++) {
        if (immediatePropagationStopped.get(event))
          break;
        matched.observers[j].data.call(matched.node, event);
      }
    }
    currentTargets["delete"](event);
    defineCurrentTarget(event);
  }
  function on(name, selector, fn) {
    var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    var capture = options.capture ? true : false;
    var events = capture ? captureEvents : bubbleEvents;
    var selectors = events[name];
    if (!selectors) {
      selectors = new SelectorSet();
      events[name] = selectors;
      document.addEventListener(name, dispatch, capture);
    }
    selectors.add(selector, fn);
  }
  function off(name, selector, fn) {
    var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    var capture = options.capture ? true : false;
    var events = capture ? captureEvents : bubbleEvents;
    var selectors = events[name];
    if (!selectors)
      return;
    selectors.remove(selector, fn);
    if (selectors.size)
      return;
    delete events[name];
    document.removeEventListener(name, dispatch, capture);
  }
  function fire(target, name, detail) {
    return target.dispatchEvent(new CustomEvent(name, {
      bubbles: true,
      cancelable: true,
      detail
    }));
  }

  // _remake/client-side/queryjs/index.js
  var $ = function(selector) {
    return new QueryObj(selector);
  };
  $.on = on;
  $.off = off;
  $.fire = fire;
  let data = [];
  $.data = function(elem, key, value) {
    if (!elem || !key) {
      return;
    }
    if (!value) {
      let match = data.find((item) => item.elem === elem && item.key === key);
      return match && match.value;
    }
    if (value) {
      let existingIndex = data.findIndex((item) => item.elem === elem && item.key === key);
      if (existingIndex > -1) {
        data.splice(existingIndex, 1);
      }
      data.push({key, value, elem});
    }
  };
  $.arr = function(arrLike) {
    if (arrLike === null || arrLike === void 0) {
      return [];
    } else {
      return Array.from(arrLike);
    }
  };
  class QueryObj {
    constructor(selector) {
      let nodeList = document.querySelectorAll(selector);
      let nodeListArr = Array.from(nodeList);
      if (selector.endsWith(":first")) {
        nodeListArr = nodeListArr.slice(0, 1);
      }
      this.arr = nodeListArr;
    }
    get(index) {
      if (index === void 0) {
        return this.arr;
      }
      try {
        return this.arr[index];
      } catch (err) {
        return void 0;
      }
    }
    data(key, value) {
      for (var i = 0; i < this.arr.length; i++) {
        let elem = this.arr[i];
        $.data(elem, key, value);
      }
    }
    on(name, cb) {
      this.arr.forEach((el) => {
        el.addEventListener(name, cb);
      });
    }
  }

  // _remake/client-side/hummingbird/lib/dom/index.js
  function getParents({elem, selector, includeCurrentElement}) {
    let parents = [];
    if (!includeCurrentElement) {
      elem = elem.parentNode;
    }
    for (; elem && elem !== document; elem = elem.parentNode) {
      if (!selector || selector && elem.matches(selector)) {
        parents.push(elem);
      }
    }
    return parents;
  }
  function findNearest({elem, selector}) {
    if (elem === document.documentElement) {
      return;
    }
    if (elem.matches(selector)) {
      return elem;
    }
    let matchingChildElem = elem.querySelector(selector);
    if (matchingChildElem) {
      return matchingChildElem;
    }
    return findNearest({elem: elem.parentElement, selector});
  }
  function forEachAttr(elem, fn) {
    let attributes = elem.attributes;
    let attributesLength = attributes.length;
    for (var i = 0; i < attributesLength; i++) {
      let attrName = attributes[i].name;
      let attrValue = attributes[i].value;
      fn(attrName, attrValue);
    }
  }
  function getElementOffset(el) {
    let clientRect = el.getBoundingClientRect();
    let top = clientRect.top + window.pageYOffset;
    let left = clientRect.left + window.pageXOffset;
    let right = clientRect.width + left;
    let bottom = clientRect.height + top;
    let width = right - left;
    let height = bottom - top;
    return {
      top,
      right,
      bottom,
      left,
      width,
      height
    };
  }
  function getAttributeNames({elem}) {
    let elemAttributes = elem.attributes;
    let attributes = [];
    for (let i = 0; i < elemAttributes.length; i++) {
      attributes.push(elemAttributes[i].name);
    }
    return attributes;
  }
  function getAttributesThatElemMatchesPartOf({elem, partialAttributeString}) {
    let elemAttributes = getAttributeNames({elem});
    return elemAttributes.filter((attr) => attr.indexOf(partialAttributeString) !== -1);
  }
  function onAttributeEvent({
    eventTypes = ["click"],
    partialAttributeStrings,
    matchesSelectors,
    callback,
    groupMatchesIntoSingleCallback,
    filterOutElemsInsideAncestor
  }) {
    eventTypes.forEach((eventType) => {
      document.addEventListener(eventType, function(event) {
        let targetElem = event.target;
        if (filterOutElemsInsideAncestor && targetElem.closest(filterOutElemsInsideAncestor)) {
          return;
        }
        let elemAndParents = getParents({elem: targetElem, includeCurrentElement: true});
        let matchingElems = [];
        for (let i = 0; i < elemAndParents.length; i++) {
          let elem = elemAndParents[i];
          partialAttributeStrings.forEach((partialAttributeString) => {
            let matchingAttributes = getAttributesThatElemMatchesPartOf({elem, partialAttributeString});
            matchingAttributes.forEach((matchingAttribute) => {
              if (!matchesSelectors || matchesSelectors.every((selector) => elem.matches(selector))) {
                matchingElems.push({
                  matchingElement: elem,
                  matchingAttribute,
                  value: elem.value || "",
                  eventType,
                  matchingPartialAttributeString: partialAttributeString
                });
              }
            });
          });
        }
        if (matchingElems.length) {
          if (!groupMatchesIntoSingleCallback) {
            matchingElems.forEach((m) => callback(m));
          } else {
            callback(matchingElems);
          }
        }
      });
    });
  }

  // _remake/client-side/parse-data-attributes/index.js
  function removeSpacesInParentheses(str) {
    let letters = str.split("");
    let newLetters = [];
    let inParentheses = false;
    for (let i = 0; i < letters.length; i++) {
      let currentLetter = letters[i];
      if (currentLetter === "(") {
        inParentheses = true;
      } else if (currentLetter === ")") {
        inParentheses = false;
      } else if (inParentheses && currentLetter === " ") {
        currentLetter = "";
      }
      newLetters.push(currentLetter);
    }
    return newLetters.join("");
  }
  function formatSpaces(str) {
    return str.trim().replace(/  +/g, " ");
  }
  function parseAttributeString(attributesString) {
    let formattedString = removeSpacesInParentheses(formatSpaces(attributesString));
    let separatedParamSections = formattedString.split(" ");
    let separatedAllParams = separatedParamSections.map((str) => str.replace(/\s|\)/g, "").split(/\(|,/));
    return separatedAllParams;
  }
  function makeParseFunction(attributeName, keyNames) {
    return function parseFunction(elem) {
      let attributesString = elem.getAttribute(attributeName);
      if (!attributesString) {
        return [];
      }
      let parsedAttributeValues = parseAttributeString(attributesString);
      return parsedAttributeValues.map(function(arrayOfValues) {
        let returnObj = {};
        keyNames.forEach(function(keyName, index) {
          let val = arrayOfValues[index];
          if (val) {
            returnObj[keyName] = arrayOfValues[index];
          }
        });
        return returnObj;
      });
    };
  }
  let parseSwitchAttributes = makeParseFunction("data-switches", ["name", "auto", "customName"]);
  let parseSwitchActionAttributes = makeParseFunction("data-switch-actions", ["name", "type", "context"]);
  let parseSwitchStopAttributes = makeParseFunction("data-switch-stop", ["name"]);
  let parseSwitchedOnAttributes = makeParseFunction("data-switched-on", ["name"]);
  function parseStringWithIndefiniteNumberOfParams(attributesString) {
    if (!attributesString) {
      return [];
    }
    let parsedAttributeValues = parseAttributeString(attributesString);
    return parsedAttributeValues.map(function(arrayOfValues) {
      return {
        funcName: arrayOfValues[0],
        args: arrayOfValues.slice(1)
      };
    });
  }
  function makeSimpleParseFunction(attributeName, keyNames) {
    return function parseFunction(elem) {
      let attributesString = elem.getAttribute(attributeName);
      if (!attributesString) {
        return {};
      }
      attributesString = formatSpaces(attributesString);
      let parsedAttributeValues = attributesString.split(" ");
      return parsedAttributeValues.reduce((accumulator, currentValue, index) => {
        let keyName = keyNames[index];
        accumulator[keyName] = currentValue;
        return accumulator;
      }, {});
    };
  }
  let parseCopyLayoutAttributes = makeSimpleParseFunction("data-copy-layout", ["selectorForPositionTarget", "xOffset", "yOffset", "dimensionsName", "selectorForDimensionsTarget"]);
  let parseCopyPositionAttributes = makeSimpleParseFunction("data-copy-position", ["selectorForPositionTarget", "xOffset", "yOffset"]);
  let parseCopyDimensionsAttributes = makeSimpleParseFunction("data-copy-dimensions", ["selectorForDimensionsTarget", "dimensionsName"]);
  function getAttributeValueAsArray(elem, attributeName) {
    let attributesString = elem.getAttribute(attributeName);
    if (!attributesString) {
      return [];
    }
    attributesString = formatSpaces(attributesString);
    return attributesString.split(" ");
  }

  // _remake/client-side/copy-layout/index.js
  let lookupParser = [
    {
      selector: "[data-copy-layout]",
      parser: parseCopyLayoutAttributes,
      name: "both"
    },
    {
      selector: "[data-copy-position]",
      parser: parseCopyPositionAttributes,
      name: "position"
    },
    {
      selector: "[data-copy-dimensions]",
      parser: parseCopyDimensionsAttributes,
      name: "dimensions"
    }
  ];
  $.on("click", "[data-copy-layout], [data-copy-position], [data-copy-dimensions]", (event) => {
    let sourceElement = event.currentTarget;
    let listOfElementLayoutData = getListOfElementLayoutData(sourceElement);
    listOfElementLayoutData.forEach(({
      selectorForPositionTarget,
      xOffset,
      yOffset,
      dimensionsName,
      selectorForDimensionsTarget,
      copyMethod
    }) => {
      let sourceElementOffsetData = getElementOffset(sourceElement);
      if (copyMethod === "dimensions" || copyMethod === "both") {
        if (!selectorForDimensionsTarget) {
          selectorForDimensionsTarget = selectorForPositionTarget;
        }
        copyDimensions(sourceElementOffsetData, selectorForDimensionsTarget, dimensionsName);
      }
      if (copyMethod === "position" || copyMethod === "both") {
        copyPosition(sourceElementOffsetData, selectorForPositionTarget, xOffset, yOffset);
      }
    });
  });
  function getListOfElementLayoutData(sourceElement) {
    let parsedData = [];
    lookupParser.forEach((parser) => {
      if (sourceElement.matches(parser.selector)) {
        let elemData = parser.parser(sourceElement);
        elemData.copyMethod = parser.name;
        if (elemData.xOffset) {
          elemData.xOffset = parseInt(elemData.xOffset, 10);
        }
        if (elemData.yOffset) {
          elemData.yOffset = parseInt(elemData.yOffset, 10);
        }
        parsedData.push(elemData);
      }
    });
    return parsedData;
  }
  function copyDimensions(sourceElementOffsetData, selectorForDimensionsTarget, dimensionsName) {
    let {width, height} = sourceElementOffsetData;
    $(selectorForDimensionsTarget).arr.forEach((targetElem) => {
      if (dimensionsName === "width" || dimensionsName === "both") {
        targetElem.style.width = width + "px";
      }
      if (dimensionsName === "height" || dimensionsName === "both") {
        targetElem.style.height = height + "px";
      }
    });
  }
  function copyPosition(sourceElementOffsetData, selectorForPositionTarget, xOffset = 0, yOffset = 0) {
    let {left, top} = sourceElementOffsetData;
    left += xOffset;
    top += yOffset;
    $(selectorForPositionTarget).arr.forEach((targetElem) => {
      targetElem.style.top = top + "px";
      targetElem.style.left = left + "px";
    });
  }
  function copyLayout({sourceElem, targetElem, dimensionsName = "width", xOffset = 0, yOffset = 0} = {}) {
    let sourceElemOffsetData = getElementOffset(sourceElem);
    let {left, top} = sourceElemOffsetData;
    left += xOffset;
    top += yOffset;
    targetElem.style.top = top + "px";
    targetElem.style.left = left + "px";
    let {width, height} = sourceElemOffsetData;
    if (dimensionsName === "width" || dimensionsName === "both") {
      targetElem.style.width = width + "px";
    }
    if (dimensionsName === "height" || dimensionsName === "both") {
      targetElem.style.height = height + "px";
    }
  }

  // _remake/client-side/common/get-valid-element-properties.js
  function getValidElementProperties() {
    return ["id", "className", "type", "src", "href", "value", "checked", "innerText", "innerHTML", "style", "title", "alt", "for", "placeholder"];
  }
  const validPropertyCommands = getValidElementProperties().map((p) => "@" + p);
  function isValidCommand({commandName, includingSearchCommand = false}) {
    return includingSearchCommand && commandName === "@search" || validPropertyCommands.includes(commandName) || commandName.indexOf("@attr:") === 0;
  }

  // _remake/client-side/common/show-error.js
  function showError(...messages) {
    console.error("Remake Error:", ...messages);
  }

  // _remake/client-side/inputjs/optionsData.js
  var optionsData_default = {
    watchFunctions: {
      setMailToLink: ({watchElem, value}) => {
        watchElem.href = "mailto:" + value;
      },
      setLink: ({watchElem, value}) => {
        watchElem.href = value.startsWith("http") ? value : `https://${value}`;
      },
      countKeys: ({dashCaseKeyName, watchFuncArgs}) => {
        let [selector] = watchFuncArgs;
        let targetElem = document.querySelector(selector);
        if (targetElem) {
          let elemsThatMatchKey = Array.from(document.querySelectorAll(`[key\\:${dashCaseKeyName}]`));
          let count = elemsThatMatchKey.reduce((count2, el) => {
            let keyValue = el.getAttribute(`key:${dashCaseKeyName}`);
            if (keyValue !== "false" && keyValue !== "off") {
              count2++;
            }
            return count2;
          }, 0);
          targetElem.innerText = count;
        }
      },
      sumKeyValues: ({dashCaseKeyName, watchFuncArgs}) => {
        let [selector] = watchFuncArgs;
        let targetElem = document.querySelector(selector);
        if (targetElem) {
          let elemsThatMatchKey = Array.from(document.querySelectorAll(`[key\\:${dashCaseKeyName}]`));
          let sum = elemsThatMatchKey.reduce((sum2, elem) => {
            let keyValue = Remake.getValueForKeyName({elem, keyName: dashCaseKeyName});
            let keyAsNumber = parseInt(keyValue) || 0;
            sum2 += keyAsNumber;
            return sum2;
          }, 0);
          targetElem.innerText = sum;
        }
      }
    },
    onSaveCallbacks: [],
    onFileUploadCallbacks: [],
    onFileUploadProgressCallbacks: [],
    onAddItemCallbacks: [],
    onRemoveItemCallbacks: [],
    onSyncCallbacks: []
  };

  // _remake/client-side/data-utilities/commandAndWatchHelpers.js
  const camelCase = require_camelCase();
  const difference = require_difference();
  function callWatchFunctionsOnElements(elems) {
    elems.forEach((elem) => {
      forEachAttr(elem, (attrName, attrValue) => {
        if (attrName.indexOf("watch:") === 0) {
          let dashCaseKeyName = attrName.substring("watch:".length);
          let closestElemWithKey = getClosestElemWithKey({elem, keyName: dashCaseKeyName});
          let value = getValueForKeyName({elem: closestElemWithKey, keyName: dashCaseKeyName});
          let targetElems = getTargetElemsForKeyName({elem, keyName: dashCaseKeyName});
          triggerWatchAttributes({elem, dashCaseKeyName, value, targetElems});
        }
      });
    });
  }
  function triggerWatchAttributes({elem, dashCaseKeyName, value, targetElems}) {
    let selector = `[watch\\:${dashCaseKeyName}]`;
    let attr = `watch:${dashCaseKeyName}`;
    let watchElems = difference(elem.querySelectorAll(selector), elem.querySelectorAll(`:scope [key\\:${dashCaseKeyName}] [watch\\:${dashCaseKeyName}]`));
    if (elem.matches(selector)) {
      watchElems.unshift(elem);
    }
    watchElems.forEach((watchElem) => {
      let watchAttrValue = watchElem.getAttribute(attr);
      let listOfCommands = parseStringWithIndefiniteNumberOfParams(watchAttrValue);
      listOfCommands.forEach(({funcName, args}) => {
        if (isValidCommand({commandName: funcName})) {
          executeCommand({elem: watchElem, commandName: funcName, value, method: "set"});
        } else {
          let watchFunc = optionsData_default.watchFunctions && optionsData_default.watchFunctions[funcName];
          if (typeof watchFunc === "function") {
            watchFunc({
              watchElem,
              watchAttrName: attr,
              watchAttrValue,
              dashCaseKeyName,
              camelCaseKeyName: camelCase(dashCaseKeyName),
              value,
              watchFuncName: funcName,
              watchFuncArgs: args,
              dataSourceElem: elem,
              dataTargetElems: targetElems
            });
          }
        }
      });
    });
  }
  function executeCommandOnMultipleElements({targetElems = [], targetAttr, value, method}) {
    for (let i = 0; i < targetElems.length; i++) {
      let targetElem = targetElems[i];
      let commandName = targetElem.getAttribute(targetAttr);
      if (isValidCommand({commandName})) {
        if (method === "set") {
          executeCommand({elem: targetElem, commandName, value, method});
        } else {
          return executeCommand({elem: targetElem, commandName, value, method});
        }
      }
    }
  }
  function getTargetsForCommand({elem, dashCaseKeyName, attrName, attrValue}) {
    let targetAttr;
    let targetElems;
    if (attrValue === "@search") {
      let selector = `[target\\:${dashCaseKeyName}]`;
      targetAttr = `target:${dashCaseKeyName}`;
      targetElems = Array.from(elem.querySelectorAll(selector));
      if (elem.matches(selector)) {
        targetElems.unshift(elem);
      }
    } else {
      targetAttr = attrName;
      targetElems = [elem];
    }
    return {targetElems, targetAttr};
  }
  function executeCommand({elem, commandName, value, method}) {
    if (commandName.indexOf("@attr:") === 0) {
      let attr = commandName.substring("@attr:".length);
      if (method === "set") {
        elem.setAttribute(attr, value);
      } else {
        return elem.getAttribute(attr);
      }
    } else {
      let prop = commandName.substring("@".length);
      if (method === "set") {
        elem[prop] = value;
      } else {
        return elem[prop];
      }
    }
  }

  // _remake/client-side/data-utilities/getAndSetKeyValues.js
  const dashCase = require_kebabCase();
  const debounce = require_debounce();
  function _valueForKeyName({method, elem, keyName, value = ""}) {
    let dashCaseKeyName = dashCase(keyName);
    let normalKeyExists = elem.hasAttribute("key:" + dashCaseKeyName);
    let temporaryKeyExists = elem.hasAttribute("temporary:key:" + dashCaseKeyName);
    if (!normalKeyExists && !temporaryKeyExists) {
      showError("You can't set a key name to a value if the key doesn't exist on the element yet");
      return;
    }
    let attrName = normalKeyExists ? "key:" + dashCaseKeyName : "temporary:key:" + dashCaseKeyName;
    let attrValue = elem.getAttribute(attrName);
    let hasValidCommand = isValidCommand({commandName: attrValue, includingSearchCommand: true});
    if (method === "set" && elem.hasAttribute(`default:${dashCaseKeyName}`) && value.trim().length === 0) {
      value = elem.getAttribute(`default:${dashCaseKeyName}`) || "";
    }
    let targetElems;
    let targetAttr;
    if (!hasValidCommand) {
      targetElems = [elem];
      if (method === "set") {
        elem.setAttribute(attrName, value);
      } else {
        return elem.getAttribute(attrName);
      }
    } else {
      let targets = getTargetsForCommand({elem, dashCaseKeyName, attrName, attrValue});
      targetElems = targets.targetElems;
      targetAttr = targets.targetAttr;
      if (method === "set") {
        executeCommandOnMultipleElements({targetElems, targetAttr, value, method});
      } else {
        return executeCommandOnMultipleElements({targetElems, targetAttr, value, method});
      }
    }
    if (method === "set") {
      let settingTemporaryKey = attrName.startsWith("temporary:");
      if (!settingTemporaryKey) {
        callSaveFunction(elem);
      }
      triggerWatchAttributes({elem, dashCaseKeyName, value, targetElems});
    }
  }
  function getTargetElemsForKeyName({elem, keyName}) {
    let dashCaseKeyName = dashCase(keyName);
    let normalKeyExists = elem.hasAttribute("key:" + dashCaseKeyName);
    let attrName = normalKeyExists ? "key:" + dashCaseKeyName : "temporary:key:" + dashCaseKeyName;
    let attrValue = elem.getAttribute(attrName);
    let hasValidCommand = isValidCommand({commandName: attrValue, includingSearchCommand: true});
    let targetElems;
    if (!hasValidCommand) {
      targetElems = [elem];
    } else {
      let targets = getTargetsForCommand({elem, dashCaseKeyName, attrName, attrValue});
      targetElems = targets.targetElems;
    }
    return targetElems;
  }
  function setValueForKeyName({elem, keyName, value}) {
    _valueForKeyName({method: "set", elem, keyName, value});
  }
  function getValueForKeyName({elem, keyName}) {
    return _valueForKeyName({method: "get", elem, keyName});
  }
  function getClosestElemWithKey({elem, keyName}) {
    let dashCaseKeyName = dashCase(keyName);
    let closestKeyElem = elem.closest(`[key\\:${dashCaseKeyName}]`);
    let closestTempKeyElem = !closestKeyElem && elem.closest(`[temporary\\:key\\:${dashCaseKeyName}]`);
    return closestKeyElem || closestTempKeyElem;
  }
  function _valueForClosestKey({method, elem, keyName, value}) {
    let closestElemWithKey = getClosestElemWithKey({elem, keyName});
    if (closestElemWithKey) {
      if (method === "set") {
        setValueForKeyName({elem: closestElemWithKey, keyName, value});
      } else {
        return getValueForKeyName({elem: closestElemWithKey, keyName});
      }
    }
  }
  function getValueForClosestKey({elem, keyName}) {
    return _valueForClosestKey({method: "get", elem, keyName});
  }
  function setValueForClosestKey({elem, keyName, value}) {
    _valueForClosestKey({method: "set", elem, keyName, value});
  }
  function getKeyNamesFromElem(elem) {
    let keyPrefix = "key:";
    let temporaryKeyPrefix = "temporary:key:";
    let keyNames = [];
    forEachAttr(elem, (attrName) => {
      if (attrName.indexOf(keyPrefix) === 0) {
        let keyName = attrName.substring(keyPrefix.length);
        keyNames.push(keyName);
      }
      if (attrName.indexOf(temporaryKeyPrefix) === 0) {
        let keyName = attrName.substring(temporaryKeyPrefix.length);
        keyNames.push(keyName);
      }
    });
    return keyNames;
  }

  // _remake/client-side/data-utilities/clearDataOnElement.js
  const camelCase2 = require_camelCase();
  function setAllDataToEmptyStringsExceptIds(elem) {
    forEachAttr(elem, function(attrName, attrValue) {
      let keyPrefix = "key:";
      if (attrName.startsWith(keyPrefix) && attrName !== "key:id") {
        let keyName = attrName.substring(keyPrefix.length);
        setValueForKeyName({elem, keyName, value: ""});
      }
      let temporaryKeyPrefix = "temporary:key:";
      if (attrName.startsWith(temporaryKeyPrefix) && attrName !== "key:id") {
        let keyName = attrName.substring(temporaryKeyPrefix.length);
        setValueForKeyName({elem, keyName, value: ""});
      }
    });
  }

  // _remake/client-side/get-save-data/getSaveDataHelpers.js
  const camelCase3 = require_camelCase();
  function createDataObjectFromElement(elem) {
    let nodeData = parseNodeForSave(elem);
    if (nodeData.key) {
      let innerData = nodeData.value;
      let outerData = {};
      outerData[nodeData.key] = innerData;
      return [innerData, outerData];
    } else {
      return [nodeData.value, nodeData.value];
    }
  }
  function addDataFromElementToDataObject(elem, parentData) {
    let isParentDataAnObject = !Array.isArray(parentData);
    let nodeData = parseNodeForSave(elem);
    if (isParentDataAnObject) {
      if (nodeData.key) {
        parentData[nodeData.key] = nodeData.value;
        return nodeData.value;
      } else {
        Object.assign(parentData, nodeData.value);
        return parentData;
      }
    } else {
      parentData.push(nodeData.value);
      return nodeData.value;
    }
  }
  function parseNodeForSave(elem) {
    return {
      key: elem.getAttribute("key"),
      value: elem.hasAttribute("array") ? [] : getSaveDataFromElement(elem)
    };
  }
  function getSaveDataFromElement(elem) {
    let keyPrefix = "key:";
    let data2 = {};
    forEachAttr(elem, (attrName) => {
      if (attrName.indexOf(keyPrefix) === 0) {
        let keyName = attrName.substring(keyPrefix.length);
        let camelCaseKeyName = camelCase3(keyName);
        data2[camelCaseKeyName] = getValueForKeyName({elem, keyName});
      }
    });
    return data2;
  }

  // _remake/client-side/get-save-data/getSaveData.js
  function getSaveData(rootNode) {
    let rootData;
    function getDataFromDom(currentElement, parentData) {
      let canElementDataBeParsed = currentElement.hasAttribute("object") || currentElement.hasAttribute("array");
      let skipElemAndChildren = currentElement.hasAttribute("ignore-data");
      if (skipElemAndChildren) {
        return;
      }
      if (canElementDataBeParsed) {
        if (parentData) {
          parentData = addDataFromElementToDataObject(currentElement, parentData);
        }
        if (!parentData && !rootData) {
          [parentData, rootData] = createDataObjectFromElement(currentElement);
        } else if (!parentData && rootData) {
          parentData = addDataFromElementToDataObject(currentElement, rootData);
        }
      }
      let children = currentElement.children;
      for (var i = 0; i < children.length; i++) {
        getDataFromDom(children[i], parentData);
      }
      return rootData;
    }
    return getDataFromDom(rootNode);
  }

  // _remake/client-side/hummingbird/lib/ajax/index.js
  function ajax({url, method, data: data2, callback}) {
    fetch(url, {
      method,
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json; charset=utf-8",
        "X-Requested-With": "XMLHttpRequest"
      },
      body: JSON.stringify(data2)
    }).then((res) => res.json()).then((res) => {
      callback(res);
    });
  }
  function ajaxSimple(url, method, data2, callback) {
    ajax({url, method, data: data2, callback});
  }
  function ajaxPost(url, data2, callback) {
    ajaxSimple(url, "POST", data2, callback);
  }
  function ajaxFileUpload({fileInputElem, onProgress, onSuccess, onError} = {}) {
    let xhr = new XMLHttpRequest();
    let file = fileInputElem.files[0];
    let formData = new FormData();
    formData.append("file", file, file.name);
    xhr.open("POST", "/upload", true);
    xhr.setRequestHeader("Accept", "application/json");
    xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
    xhr.responseType = "json";
    xhr.onreadystatechange = function(e) {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          if (onSuccess) {
            onSuccess(xhr.response);
          }
        } else {
          if (onError) {
            onError();
          }
        }
      }
    };
    xhr.upload.onprogress = function(e) {
      if (e.lengthComputable) {
        if (onProgress) {
          let progress = Math.floor(e.loaded / e.total * 100);
          onProgress(progress);
        }
      }
    };
    xhr.upload.onloadstart = function(e) {
      if (onProgress) {
        onProgress(0);
      }
    };
    xhr.upload.onloadend = function(e) {
      if (onProgress) {
        onProgress(100);
      }
    };
    xhr.send(formData);
  }

  // _remake/client-side/inputjs/callbacks.js
  function onSave2(cb) {
    optionsData_default.onSaveCallbacks.push(cb);
  }
  function onFileUpload(cb) {
    optionsData_default.onFileUploadCallbacks.push(cb);
  }
  function onFileUploadProgress(cb) {
    optionsData_default.onFileUploadProgressCallbacks.push(cb);
  }
  function onAddItem(cb) {
    optionsData_default.onAddItemCallbacks.push(cb);
  }
  function onRemoveItem(cb) {
    optionsData_default.onRemoveItemCallbacks.push(cb);
  }
  function onSync(cb) {
    optionsData_default.onSyncCallbacks.push(cb);
  }
  function callOnSaveCallbacks(...args) {
    optionsData_default.onSaveCallbacks.forEach((cb) => cb(...args));
  }
  function callOnFileUploadCallbacks(...args) {
    optionsData_default.onFileUploadCallbacks.forEach((cb) => cb(...args));
  }
  function callOnFileUploadProgressCallbacks(...args) {
    optionsData_default.onFileUploadProgressCallbacks.forEach((cb) => cb(...args));
  }
  function callOnAddItemCallbacks(...args) {
    optionsData_default.onAddItemCallbacks.forEach((cb) => cb(...args));
  }
  function callOnRemoveItemCallbacks(...args) {
    optionsData_default.onRemoveItemCallbacks.forEach((cb) => cb(...args));
  }
  function callOnSyncCallbacks(...args) {
    optionsData_default.onSyncCallbacks.forEach((cb) => cb(...args));
  }

  // _remake/client-side/inputjs/onSave.js
  let saveFunctionsLookup = {
    _defaultSave: function({data: data2, path, saveToId, elem}) {
      ajaxPost("/save", {data: data2, path, saveToId}, function(res) {
        callOnSaveCallbacks(res);
      });
    }
  };
  function initSaveFunctions() {
    if (optionsData_default.saveFunctions) {
      Object.assign(saveFunctionsLookup, optionsData_default.saveFunctions);
    }
  }
  function callSaveFunction(targetElem) {
    let saveEnabled = !targetElem.closest("[no-save]");
    if (!saveEnabled) {
      return;
    }
    let saveElement = targetElem.closest("[custom-save], [key\\:id]");
    let isDefaultingToDataKeyIdSave = false;
    let isDefaultingToGlobalSave = false;
    let hasCustomSaveFunction = false;
    let saveFuncName = "_defaultSave";
    let savePath;
    let saveToId;
    if (!saveElement) {
      saveElement = document.body;
      isDefaultingToGlobalSave = true;
      saveFuncName = "_defaultSave";
    } else {
      if (saveElement.matches("[custom-save]")) {
        hasCustomSaveFunction = true;
        [saveFuncName, savePath, saveToId] = getSaveFuncInfo(saveElement);
      } else if (saveElement.matches("[key\\:id]")) {
        isDefaultingToDataKeyIdSave = true;
        saveFuncName = "_defaultSave";
        saveToId = saveElement.getAttribute("key:id");
      }
    }
    let saveFunc = saveFunctionsLookup[saveFuncName];
    let dataInsideSaveElement = getSaveData(saveElement);
    saveFunc({data: dataInsideSaveElement, elem: targetElem, path: savePath, saveToId});
    let itemIdFromUrl = document.body.getAttribute("data-item-route");
    if (isDefaultingToGlobalSave && itemIdFromUrl) {
      console.log(`%cWarning: Data was just saved to your database, but not to the item matching the id in this page's url: "${itemIdFromUrl}". This might not be a mistake, but if it is you can correct it just add "key:${itemIdFromUrl}" to a high-level element.`, "color: #e03131;");
    }
    if (optionsData_default.logDataOnSave) {
      let logDataOnSaveString = "";
      logDataOnSaveString += "[Dev mode] Logging Remake Data on save: ";
      if (isDefaultingToGlobalSave) {
        logDataOnSaveString += "Action: Saved entire page, ";
      } else if (isDefaultingToDataKeyIdSave) {
        logDataOnSaveString += `Action: Saved to nearest id (${saveToId}), `;
      } else if (hasCustomSaveFunction) {
        logDataOnSaveString += `Action: Saved to custom save function (${saveFuncName}), `;
        if (savePath) {
          logDataOnSaveString += `Action: Saved to path: ${savePath}, `;
        }
        if (saveToId) {
          logDataOnSaveString += `Action: Saved to id: ${saveToId}, `;
        }
      }
      console.log(logDataOnSaveString, "Data:", dataInsideSaveElement);
    }
  }
  function callSaveFunctionNextTick(...args) {
    setTimeout(() => {
      callSaveFunction(...args);
    });
  }
  function getSaveFuncInfo(saveElement) {
    let dashCaseAttrName = "custom-save";
    let args = getAttributeValueAsArray(saveElement, dashCaseAttrName);
    let funcName, savePath, saveToId;
    args.forEach((arg) => {
      if (arg.startsWith("path:")) {
        savePath = arg.substring("path:".length);
      } else if (arg.startsWith("id:")) {
        saveToId = arg.substring("id:".length);
      } else {
        funcName = arg;
      }
    });
    funcName = funcName || "_defaultSave";
    return [funcName, savePath, saveToId];
  }

  // _remake/client-side/inputjs/syncData.js
  const dashCase2 = require_kebabCase();
  function syncData({keyNames = [], sourceElement, targetElement, shouldSyncIntoUpdateElems = false}) {
    keyNames.forEach((keyName) => {
      let value = getValueForClosestKey({elem: sourceElement, keyName});
      setValueForClosestKey({elem: targetElement, keyName, value, dontSave: true});
      if (shouldSyncIntoUpdateElems) {
        syncIntoUpdateElem({targetElement, keyName, value});
      }
    });
    callOnSyncCallbacks({keyNames, sourceElement, targetElement, shouldSyncIntoUpdateElems});
    callSaveFunction(targetElement);
  }
  function syncDataNextTick(...args) {
    setTimeout(() => {
      syncData(...args);
    });
  }
  function syncIntoUpdateElem({targetElement, keyName, value}) {
    let dashCaseKeyName = dashCase2(keyName);
    let elem = targetElement.querySelector(`[update\\:${dashCaseKeyName}]`);
    if (elem) {
      let tagName = elem.tagName.toLowerCase();
      if (tagName === "input") {
        let inputType = elem.getAttribute("type");
        if (inputType === "radio") {
          let matchingRadioElem = targetElement.querySelector(`[type='radio'][update\\:'${dashCaseKeyName}'][value='${value}']`);
          if (matchingRadioElem) {
            matchingRadioElem.checked = true;
          }
        } else if (inputType === "checkbox") {
          if (value !== "false" && value !== "") {
            elem.checked = false;
          } else {
            elem.checked = true;
          }
        } else if (inputType === "text" || !inputType) {
          elem.value = value;
        }
      } else if (tagName === "select" || tagName === "textarea") {
        elem.value = value;
      }
    }
  }

  // _remake/client-side/inputjs/removeAndHideEventListeners.js
  function initRemoveAndHideEventListeners() {
    $.on("click", "[remove],[remove\\:with-confirm]", function(event) {
      if (event.target.closest("[disable-events]")) {
        return;
      }
      if (event.currentTarget.hasAttribute("remove:with-confirm")) {
        if (!window.confirm("Are you sure you want to delete this element?")) {
          return;
        }
      }
      let syncElement = event.currentTarget.closest("[sync]");
      let sourceElement;
      if (syncElement) {
        sourceElement = $.data(syncElement, "source");
      } else {
        sourceElement = event.currentTarget;
      }
      let elemWithData = sourceElement.closest("[object]");
      let parentElement = elemWithData.parentElement;
      elemWithData.remove();
      callSaveFunctionNextTick(parentElement);
      callOnRemoveItemCallbacks();
    });
    $.on("click", "[erase],[erase\\:with-confirm]", function(event) {
      if (event.target.closest("[disable-events]")) {
        return;
      }
      if (event.currentTarget.hasAttribute("erase:with-confirm")) {
        if (!window.confirm("Are you sure you want to clear this data?")) {
          return;
        }
      }
      let syncElement = event.currentTarget.closest("[sync]");
      if (syncElement) {
        setAllDataToEmptyStringsExceptIds(syncElement);
        syncDataNextTick({
          sourceElement: syncElement,
          targetElement: $.data(syncElement, "source"),
          keyNames: getKeyNamesFromElem(syncElement)
        });
      } else {
        let elemWithData = event.currentTarget.closest("[object]");
        setAllDataToEmptyStringsExceptIds(elemWithData);
      }
      callOnRemoveItemCallbacks();
    });
  }

  // _remake/client-side/inputjs/fileUpload.js
  function handleUpload({elem, keyName}) {
    let fileUploadStartTime2;
    let fileUploadFinishTime2;
    let fileInputElem = elem;
    let file = fileInputElem.files[0];
    if (file) {
      fileInputElem.disabled = true;
      if (!optionsData_default._defaultUploadCallback) {
        uploadFile({fileInputElem, keyName});
      } else {
        let file2 = fileInputElem.files[0];
        optionsData_default._defaultUploadCallback({fileInputElem, keyName, resetFileInput, file: file2});
      }
    }
  }
  function uploadFile({fileInputElem, keyName}) {
    ajaxFileUpload({
      fileInputElem,
      onProgress: function(percentage) {
        if (percentage === 0) {
          fileUploadStartTime = new Date().getTime();
        }
        setPercentageOnUploadingNotice(percentage);
        if (percentage === 100) {
          resetFileInput(fileInputElem);
        }
        callOnFileUploadProgressCallbacks({percentage});
      },
      onSuccess: function(res) {
        setValueForClosestKey({elem: fileInputElem, keyName, value: res.filePath});
        callOnFileUploadCallbacks({success: true, res});
      },
      onError: function() {
        resetFileInput(fileInputElem);
        callOnFileUploadCallbacks({success: false});
      }
    });
  }
  function setPercentageOnUploadingNotice(percentage) {
    let uploadingNotice = document.querySelector(".uploading-notice");
    let progressCompleteElem = document.querySelector(".uploading-notice__progress-bar-complete");
    let progressStatusElem = document.querySelector(".uploading-notice__status-percentage");
    percentage = percentage || 0;
    if (percentage > 0) {
      uploadingNotice.classList.add("uploading-notice--visible");
    }
    progressCompleteElem.style.transform = `scaleX(${percentage / 100})`;
    progressStatusElem.innerText = parseInt(percentage, 10) + "%";
    if (percentage === 100) {
      fileUploadFinishTime = new Date().getTime();
      let timeoutMs = 1500;
      if (fileUploadFinishTime - fileUploadStartTime < 2500) {
        timeoutMs = 2300;
      }
      setTimeout(function() {
        uploadingNotice.classList.remove("uploading-notice--visible");
      }, timeoutMs);
    }
  }
  function resetFileInput(elem) {
    elem.disabled = false;
    elem.value = "";
  }

  // _remake/client-side/inputjs/eventsForUpdatingData.js
  function eventsForUpdatingData_default() {
    onAttributeEvent({
      eventTypes: ["input", "click", "change"],
      partialAttributeStrings: ["update:"],
      filterOutElemsInsideAncestor: "[disable-events]",
      callback: ({eventType, matchingElement, matchingAttribute, matchingPartialAttributeString}) => {
        let keyName = matchingAttribute.substring(matchingPartialAttributeString.length);
        let nodeName = matchingElement.nodeName && matchingElement.nodeName.toLowerCase();
        let inputType = matchingElement.type ? matchingElement.type.toLowerCase() : "";
        let elem = matchingElement;
        let value = null;
        if (eventType === "input") {
          if (nodeName === "textarea" || inputType === "text" || inputType === "") {
            value = matchingElement.value;
            setValueForClosestKey({elem, keyName, value});
          }
        }
        if (eventType === "change") {
          if (inputType === "checkbox") {
            value = matchingElement.checked ? true : false;
          }
          if (inputType === "radio" || nodeName === "select") {
            value = matchingElement.value;
          }
          if (inputType === "file") {
            handleUpload({elem: matchingElement, keyName});
          }
        }
        if (eventType === "click" && !matchingElement.closest("input, textarea, select")) {
          value = matchingElement.getAttribute(matchingAttribute);
        }
        if (value !== null) {
          setValueForClosestKey({elem: matchingElement, keyName, value});
        }
      }
    });
    onAttributeEvent({
      eventTypes: ["click"],
      partialAttributeStrings: ["toggle:"],
      filterOutElemsInsideAncestor: "[disable-events]",
      callback: ({matchingElement, matchingAttribute, matchingPartialAttributeString}) => {
        let keyName = matchingAttribute.substring(matchingPartialAttributeString.length);
        let currentValue = getValueForClosestKey({elem: matchingElement, keyName}) || "";
        if (currentValue.toLowerCase() !== "true") {
          setValueForClosestKey({elem: matchingElement, keyName, value: true});
        } else {
          setValueForClosestKey({elem: matchingElement, keyName, value: false});
        }
      }
    });
  }

  // _remake/client-side/inputjs/clickToSaveEventListener.js
  function clickToSaveEventListener_default() {
    $.on("click", "[save]", function(event) {
      let clickedElem = event.currentTarget;
      if (clickedElem.closest("[disable-events]")) {
        return;
      }
      callSaveFunctionNextTick(clickedElem);
    });
  }

  // _remake/client-side/vendor/autosize.js
  const map = typeof Map === "function" ? new Map() : function() {
    const keys = [];
    const values = [];
    return {
      has(key) {
        return keys.indexOf(key) > -1;
      },
      get(key) {
        return values[keys.indexOf(key)];
      },
      set(key, value) {
        if (keys.indexOf(key) === -1) {
          keys.push(key);
          values.push(value);
        }
      },
      delete(key) {
        const index = keys.indexOf(key);
        if (index > -1) {
          keys.splice(index, 1);
          values.splice(index, 1);
        }
      }
    };
  }();
  let createEvent = (name) => new Event(name, {bubbles: true});
  try {
    new Event("test");
  } catch (e) {
    createEvent = (name) => {
      const evt = document.createEvent("Event");
      evt.initEvent(name, true, false);
      return evt;
    };
  }
  function assign(ta) {
    if (!ta || !ta.nodeName || ta.nodeName !== "TEXTAREA" || map.has(ta))
      return;
    let heightOffset = null;
    let clientWidth = null;
    let cachedHeight = null;
    function init2() {
      const style = window.getComputedStyle(ta, null);
      if (style.resize === "vertical") {
        ta.style.resize = "none";
      } else if (style.resize === "both") {
        ta.style.resize = "horizontal";
      }
      if (style.boxSizing === "content-box") {
        heightOffset = -(parseFloat(style.paddingTop) + parseFloat(style.paddingBottom));
      } else {
        heightOffset = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
      }
      if (isNaN(heightOffset)) {
        heightOffset = 0;
      }
      update2();
    }
    function changeOverflow(value) {
      {
        const width = ta.style.width;
        ta.style.width = "0px";
        ta.offsetWidth;
        ta.style.width = width;
      }
      ta.style.overflowY = value;
    }
    function getParentOverflows(el) {
      const arr = [];
      while (el && el.parentNode && el.parentNode instanceof Element) {
        if (el.parentNode.scrollTop) {
          arr.push({
            node: el.parentNode,
            scrollTop: el.parentNode.scrollTop
          });
        }
        el = el.parentNode;
      }
      return arr;
    }
    function resize() {
      if (ta.scrollHeight === 0) {
        return;
      }
      const overflows = getParentOverflows(ta);
      const docTop = document.documentElement && document.documentElement.scrollTop;
      ta.style.height = "";
      ta.style.height = ta.scrollHeight + heightOffset + "px";
      clientWidth = ta.clientWidth;
      overflows.forEach((el) => {
        el.node.scrollTop = el.scrollTop;
      });
      if (docTop) {
        document.documentElement.scrollTop = docTop;
      }
    }
    function update2() {
      resize();
      const styleHeight = Math.round(parseFloat(ta.style.height));
      const computed = window.getComputedStyle(ta, null);
      var actualHeight = computed.boxSizing === "content-box" ? Math.round(parseFloat(computed.height)) : ta.offsetHeight;
      if (actualHeight < styleHeight) {
        if (computed.overflowY === "hidden") {
          changeOverflow("scroll");
          resize();
          actualHeight = computed.boxSizing === "content-box" ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
        }
      } else {
        if (computed.overflowY !== "hidden") {
          changeOverflow("hidden");
          resize();
          actualHeight = computed.boxSizing === "content-box" ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
        }
      }
      if (cachedHeight !== actualHeight) {
        cachedHeight = actualHeight;
        const evt = createEvent("autosize:resized");
        try {
          ta.dispatchEvent(evt);
        } catch (err) {
        }
      }
    }
    const pageResize = () => {
      if (ta.clientWidth !== clientWidth) {
        update2();
      }
    };
    const destroy2 = ((style) => {
      window.removeEventListener("resize", pageResize, false);
      ta.removeEventListener("input", update2, false);
      ta.removeEventListener("keyup", update2, false);
      ta.removeEventListener("autosize:destroy", destroy2, false);
      ta.removeEventListener("autosize:update", update2, false);
      Object.keys(style).forEach((key) => {
        ta.style[key] = style[key];
      });
      map.delete(ta);
    }).bind(ta, {
      height: ta.style.height,
      resize: ta.style.resize,
      overflowY: ta.style.overflowY,
      overflowX: ta.style.overflowX,
      wordWrap: ta.style.wordWrap
    });
    ta.addEventListener("autosize:destroy", destroy2, false);
    if ("onpropertychange" in ta && "oninput" in ta) {
      ta.addEventListener("keyup", update2, false);
    }
    window.addEventListener("resize", pageResize, false);
    ta.addEventListener("input", update2, false);
    ta.addEventListener("autosize:update", update2, false);
    ta.style.overflowX = "hidden";
    ta.style.wordWrap = "break-word";
    map.set(ta, {
      destroy: destroy2,
      update: update2
    });
    init2();
  }
  function destroy(ta) {
    const methods = map.get(ta);
    if (methods) {
      methods.destroy();
    }
  }
  function update(ta) {
    const methods = map.get(ta);
    if (methods) {
      methods.update();
    }
  }
  let autosize = null;
  if (typeof window === "undefined" || typeof window.getComputedStyle !== "function") {
    autosize = (el) => el;
    autosize.destroy = (el) => el;
    autosize.update = (el) => el;
  } else {
    autosize = (el, options) => {
      if (el) {
        Array.prototype.forEach.call(el.length ? el : [el], (x) => assign(x, options));
      }
      return el;
    };
    autosize.destroy = (el) => {
      if (el) {
        Array.prototype.forEach.call(el.length ? el : [el], destroy);
      }
      return el;
    };
    autosize.update = (el) => {
      if (el) {
        Array.prototype.forEach.call(el.length ? el : [el], update);
      }
      return el;
    };
  }
  var autosize_default = autosize;

  // _remake/client-side/inputjs/editableAttribute.js
  function editableAttribute_default() {
    onAttributeEvent({
      eventTypes: ["click"],
      partialAttributeStrings: ["edit:"],
      groupMatchesIntoSingleCallback: true,
      filterOutElemsInsideAncestor: "[disable-events]",
      callback: (matches3) => {
        let editableConfig = matches3.map(({eventType, matchingElement, matchingAttribute, matchingPartialAttributeString}) => {
          let attributeParts = matchingAttribute.split(":");
          let [_, keyName, ...otherOptions] = attributeParts;
          let validRemoveOptions = ["with-remove", "without-remove", "with-erase"];
          let validFormTypes = ["text", "textarea"];
          let removeOption = validRemoveOptions.find((str) => otherOptions.includes(str)) || "with-remove";
          let formType = validFormTypes.find((str) => otherOptions.includes(str)) || "text";
          return {keyName, formType, removeOption, eventType, matchingElement, matchingAttribute, matchingPartialAttributeString};
        });
        let firstMatch = editableConfig[0];
        let firstMatchElem = firstMatch.matchingElement;
        let firstMatchKeyName = firstMatch.keyName;
        let firstMatchRemoveOption = firstMatch.removeOption;
        let firstMatchTargetElem = getClosestElemWithKey({elem: firstMatchElem, keyName: firstMatchKeyName});
        if (!firstMatchElem || !firstMatchKeyName || !firstMatchTargetElem) {
          showError(`Problem with the 'edit:' attribute on one of these elements:`, matches3.map((m) => m.matchingElement));
          return;
        }
        let editablePopoverElem = document.querySelector(".remake-edit");
        removeObjectKeysFromElem({elem: editablePopoverElem});
        let hasRemove = firstMatchRemoveOption === "with-remove";
        let hasErase = firstMatchRemoveOption === "with-erase";
        editablePopoverElem.setAttribute(`temporary:key:remake-edit-popover`, "");
        editablePopoverElem.setAttribute(`temporary:key:remake-edit-option-has-remove`, "");
        editablePopoverElem.setAttribute(`temporary:key:remake-edit-option-has-erase`, "");
        setValueForKeyName({elem: editablePopoverElem, keyName: "remake-edit-popover", value: "on"});
        setValueForKeyName({elem: editablePopoverElem, keyName: "remake-edit-option-has-remove", value: hasRemove ? "on" : "off"});
        setValueForKeyName({elem: editablePopoverElem, keyName: "remake-edit-option-has-erase", value: hasErase ? "on" : "off"});
        $.data(editablePopoverElem, "source", firstMatchTargetElem);
        addObjectKeysToElem({elem: editablePopoverElem, config: editableConfig});
        syncDataNextTick({
          sourceElement: firstMatchElem,
          targetElement: editablePopoverElem,
          keyNames: editableConfig.map((obj) => obj.keyName),
          shouldSyncIntoUpdateElems: true
        });
        let remakeEditAreasElem = editablePopoverElem.querySelector(".remake-edit__edit-areas");
        remakeEditAreasElem.innerHTML = generateRemakeEditAreas({config: editableConfig});
        copyLayout({
          sourceElem: firstMatchElem,
          targetElem: editablePopoverElem,
          dimensionsName: "width",
          xOffset: 0,
          yOffset: 0
        });
        setTimeout(function() {
          let textareas = Array.from(editablePopoverElem.querySelectorAll("textarea"));
          textareas.forEach((el) => autosize_default(el));
        });
        let firstFormInput = editablePopoverElem.querySelector("textarea, input");
        if (firstFormInput) {
          firstFormInput.focus();
        }
      }
    });
    $.on("submit", "[sync]", (event) => {
      event.preventDefault();
      let syncElement = event.currentTarget.closest("[sync]");
      syncDataNextTick({
        sourceElement: syncElement,
        targetElement: $.data(syncElement, "source"),
        keyNames: getKeyNamesFromElem(syncElement)
      });
    });
    $.on("click", ".remake-edit__button:not([type='submit'])", function(event) {
      event.preventDefault();
    });
    document.addEventListener("keydown", (event) => {
      if (event.keyCode === 27) {
        let turnedOnEditablePopover = document.querySelector('[key:remake-edit-popover="on"]');
        if (turnedOnEditablePopover) {
          setValueForKeyName({elem: turnedOnEditablePopover, keyName: "remake-edit-popover", value: "off"});
        }
      }
    });
  }
  function removeObjectKeysFromElem({elem}) {
    let attributesToRemove = [];
    forEachAttr(elem, (attrName, attrValue) => {
      if (attrName.startsWith("key:") || attrName.startsWith("temporary:key:")) {
        attributesToRemove.push(attrName);
      }
    });
    attributesToRemove.forEach((attrName) => elem.removeAttribute(attrName));
  }
  function addObjectKeysToElem({elem, config}) {
    config.forEach((obj) => {
      elem.setAttribute(`temporary:key:${obj.keyName}`, "");
    });
  }
  function generateRemakeEditAreas({config}) {
    let outputHtml = "";
    config.forEach(({formType, keyName}) => {
      let formFieldHtml;
      if (formType === "text") {
        formFieldHtml = `<input class="remake-edit__input" update:${keyName} type="text">`;
      }
      if (formType === "textarea") {
        formFieldHtml = `<textarea class="remake-edit__textarea" update:${keyName}></textarea>`;
      }
      outputHtml += `<div class="remake-edit__edit-area">${formFieldHtml}</div>`;
    });
    return outputHtml;
  }

  // _remake/client-side/inputjs/addingItemEventListener.js
  const camelCase4 = require_camelCase();
  function _defaultAddItemCallback({templateName, listElem, whereToInsert, autoedit}) {
    ajaxPost("/new", {templateName}, function(ajaxResponse) {
      let {htmlString, success} = ajaxResponse;
      if (!success) {
        callOnAddItemCallbacks({success: false, templateName, ajaxResponse});
        return;
      }
      if (!listElem) {
        showError("Couldn't find list element to insert new item into");
        return;
      }
      listElem.insertAdjacentHTML(whereToInsert, htmlString);
      callSaveFunction(listElem);
      let itemElem = whereToInsert === "afterbegin" ? listElem.firstElementChild : listElem.lastElementChild;
      if (autoedit)
        itemElem.click();
      callOnAddItemCallbacks({success: true, listElem, itemElem, templateName, ajaxResponse});
    });
  }
  function addingItemEventListener_default() {
    onAttributeEvent({
      eventTypes: ["click"],
      partialAttributeStrings: ["new:"],
      filterOutElemsInsideAncestor: "[disable-events]",
      callback: ({matchingElement, matchingAttribute}) => {
        let templateName = camelCase4(matchingAttribute.substring("new:".length));
        let argArray = getAttributeValueAsArray(matchingElement, matchingAttribute);
        let position = argArray.indexOf("top") !== -1 ? "top" : "bottom";
        let whereToInsert = position === "top" ? "afterbegin" : "beforeend";
        let selector = argArray.find((arg) => arg !== "top" && arg !== "bottom") || "[array]";
        let listElem = findNearest({elem: matchingElement, selector});
        if (!optionsData_default._defaultAddItemCallback) {
          _defaultAddItemCallback({templateName, listElem, whereToInsert, autoedit: true});
        } else {
          optionsData_default._defaultAddItemCallback({templateName, listElem, whereToInsert, autoedit: true});
        }
      }
    });
  }

  // _remake/client-side/inputjs/sortableElements.js
  function initSortableElements() {
    let {sortablejs} = optionsData_default.sortable;
    makeSortable({elemToSearch: document});
    onAddItem(function({success, listElem, itemElem, templateName, ajaxResponse}) {
      if (success) {
        makeSortable({elemToSearch: itemElem});
      }
    });
    function makeSortable({elemToSearch}) {
      let sortableElems = Array.from(elemToSearch.querySelectorAll("[sortable]"));
      sortableElems.forEach((sortableListElem) => {
        if (sortableListElem.closest("[disable-events]")) {
          return;
        }
        let sortableOptions = {
          group: sortableListElem.getAttribute("sortable") || getRandomSortableId(),
          onEnd: function(event) {
            callSaveFunction(sortableListElem);
          }
        };
        if (sortableListElem.querySelector("[sortable-handle]")) {
          sortableOptions.handle = "[sortable-handle]";
        }
        sortablejs.create(sortableListElem, sortableOptions);
      });
    }
  }
  function getRandomSortableId() {
    return "sortable-" + Math.random().toString().substring(2);
  }

  // _remake/client-side/inputjs/autoGeneratedComponents.js
  function initAutoGeneratedComponents() {
    let htmlString = `
  <style>
    /* editable components */
    [data-user-is-not-page-author] #remake__auto-generated {
      display: none;
    }

    .remake-edit {
      display: none;
      position: absolute;
      box-sizing: border-box;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    }

    .remake-edit * {
      box-sizing: border-box;
      font-family: inherit;
    }

    [temporary\\:key\\:remake-edit-popover="on"] {
      display: block;
    }

    .remake-edit__backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      z-index: 9;
    }

    .remake-edit__edit-container {
      position: absolute;
      z-index: 10;
      min-width: 280px;
      width: 100%;
    }

    .remake-edit__edit-area {
      margin-bottom: 8px;
    }

    .remake-edit__textarea, .remake-edit__input {
      display: block;
      width: 100%;
      padding: 7px 14px 9px;
      font-size: 18px;
      border: none;
      outline: none;
      line-height: 1.4em;
      box-shadow: 0 2px 2px rgba(0, 0, 0, 0.5);
      border-radius: 5px;
    }

    .remake-edit__textarea {
      min-height: 48px;
      resize: none;
    }

    .remake-edit__buttons {
      display: flex;
    }

    .remake-edit__button {
      display: inline-block;
      margin: 0 8px 0 0;
      padding: 7px 14px 9px;
      border: 0;
      outline: none;
      font-size: 18px;
      color: #fff;
      background-color: #228be6;
      line-height: 1em;
      box-shadow: 0 2px 2px rgba(0, 0, 0, 0.5);
      border-radius: 5px;
      cursor: pointer;
      user-select: none;
      text-decoration: none;
    }

    .remake-edit__button:last-child {
      margin: 0;
    }

    .remake-edit__button:hover {
      background-color: #0b6cbf;
      color: #fff;
      text-decoration: none;
    }

    .remake-edit__button--remove, .remake-edit__button--hide {
      background-color: #e03131;
    }

    .remake-edit__button--hide {
      display: none;
    }

    .remake-edit__button--remove:hover, .remake-edit__button--hide:hover {
      background-color: #b42626;
      color: #fff;
    }

    [temporary\\:key\\:remake-edit-option-has-remove="off"] .remake-edit__button--remove, [temporary\\:key\\:remake-edit-option-has-erase="on"] .remake-edit__button--remove {
      display: none;
    }

    [temporary\\:key\\:remake-edit-option-has-erase="on"] .remake-edit__button--hide {
      display: inline-block;
    }

    .remake-edit__button--cancel {
      margin-left: auto;
      background-color: #868E96;
    }

    .remake-edit__button--cancel:hover {
      background-color: #64707d;
      color: #fff;
    }

    /* upload components */
    .uploading-notice {
      display: none;
      z-index: 10;
      position: absolute;
      top: 1.5rem;
      right: 1.5rem;
      width: 240px;
      padding: 14px 19px 18px 18px;
      font-weight: bold;
      font-size: 16px;
      color: #2B292D;
      background-color: #fff;
      border-radius: 7px;
      box-shadow: 0px 2px 6px rgba(0,0,0,.24);
    }

    .uploading-notice.uploading-notice--visible {
      display: block;
    }

    .uploading-notice__status {
      display: flex;
      margin-bottom: 12px;
    }

    .uploading-notice__status-text {
    }

    .uploading-notice__status-percentage {
      margin-left: auto;
      color: #4C6EF5;
    }

    .uploading-notice__progress-bar {
      overflow: hidden;
      background-color: #DBE4FF;
      height: 16px;
      border-radius: 3px;
    }

    .uploading-notice__progress-bar-complete {
      height: 100%;
      transform-origin: left;
      transform: scaleX(0);
      transition: transform .2s;
      background-color: #4C6EF5;
    }

  </style>
  <div id="remake__auto-generated" ignore-data no-save>

    <!-- editable components -->
    <form 
      class="remake-edit" 

      sync

      object
      temporary:key:remake-edit-popover="off"
      temporary:key:remake-edit-option-has-remove="on"
      temporary:key:remake-edit-option-has-erase="off"
    >
      <div 
        class="remake-edit__backdrop"
        update:remake-edit-popover="off"
      ></div>
      <div class="remake-edit__edit-container">
        <div class="remake-edit__edit-areas">
        </div>
        <div class="remake-edit__buttons">
          <a 
            class="remake-edit__button remake-edit__button--remove" 
            href="#"
            remove
            update:remake-edit-popover="off"
          >remove</a>
          <a 
            class="remake-edit__button remake-edit__button--hide" 
            href="#"
            erase
            update:remake-edit-popover="off"
          >remove</a>
          <a 
            class="remake-edit__button remake-edit__button--cancel" 
            href="#"
            update:remake-edit-popover="off"
          >cancel</a>
          <button 
            class="remake-edit__button remake-edit__button--save" 
            type="submit"
            update:remake-edit-popover="off"
          >save</button>
        </div>
      </div>
    </form>

    <!-- upload components -->
    <div class="uploading-notice">
      <div class="uploading-notice__status">
        <div class="uploading-notice__status-text">Uploading</div>
        <div class="uploading-notice__status-percentage"></div>
      </div>
      <div class="uploading-notice__progress-bar">
        <div class="uploading-notice__progress-bar-complete"></div>
      </div>
    </div>
  </div>`;
    document.body.insertAdjacentHTML("beforeend", htmlString);
  }

  // _remake/client-side/inputjs/eventListenerHelpers.js
  function initEventListenerHelpers() {
    document.addEventListener("click", (event) => {
      if (event.target.closest("[prevent-default]")) {
        event.preventDefault();
      }
    });
  }

  // _remake/client-side/inputjs/runWatchFunctions.js
  function runWatchFunctions() {
    let watchElems = Array.from(document.querySelectorAll("[run\\:watch]"));
    Remake.callWatchFunctionsOnElements(watchElems);
  }

  // _remake/client-side/common/show-if.js
  function processShowIfAttributes() {
    var showIfElems = Array.from(document.querySelectorAll("[show-if],[flex-show-if]"));
    var filterOutProcessed = showIfElems.filter((el) => !el._processedByShowIf);
    var keyValuesStrings = [];
    filterOutProcessed.forEach((el) => {
      if (el.hasAttribute("show-if")) {
        keyValuesStrings = keyValuesStrings.concat(el.getAttribute("show-if").split(" "));
      }
      if (el.hasAttribute("flex-show-if")) {
        keyValuesStrings = keyValuesStrings.concat(el.getAttribute("flex-show-if").split(" "));
      }
      el._processedByShowIf = true;
    });
    var uniqueValues = Array.from(new Set(keyValuesStrings));
    if (uniqueValues.length) {
      var keysAndValuesSeparate = uniqueValues.map((str) => str.split("="));
      var showIfStyles = keysAndValuesSeparate.map((val) => `[key\\:${val[0]}="${val[1]}"] [show-if~="${val[0]}=${val[1]}"], [temporary\\:key\\:${val[0]}="${val[1]}"] [show-if~="${val[0]}=${val[1]}"] {display: block;} `).join("");
      showIfStyles += showIfStyles.replace(/show-if/g, "flex-show-if").replace(/block/g, "flex");
      var styleHtml = `<style>[show-if], [flex-show-if] {display: none;} ${showIfStyles}</style>`;
      document.head.insertAdjacentHTML("beforeend", styleHtml);
    }
  }

  // _remake/client-side/inputjs/index.js
  const merge = require_merge();
  function init(options) {
    if (optionsData_default.alreadyInitialized) {
      return;
    } else {
      optionsData_default.alreadyInitialized = true;
    }
    merge(optionsData_default, options);
    processShowIfAttributes();
    runWatchFunctions();
    initAutoGeneratedComponents();
    initSaveFunctions();
    initRemoveAndHideEventListeners();
    eventsForUpdatingData_default();
    clickToSaveEventListener_default();
    editableAttribute_default();
    addingItemEventListener_default();
    initEventListenerHelpers();
    if (optionsData_default.sortable) {
      initSortableElements();
    }
    onAddItem(function() {
      runWatchFunctions();
      processShowIfAttributes();
    });
    onRemoveItem(function() {
      runWatchFunctions();
    });
  }
  return require_client_side();
})();
'//# sourceMappingURL=remake.min.js.map' 
